<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>CENTENNIAL</title>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Noto+Sans+KR:wght@300;400;700&display=swap');
      :root {
        --bg: #050507;
        --bg2: #08080c;
        --bg3: #0c0c12;
        --bg4: #121218;
        --b1: #1a1a25;
        --b2: #252535;
        --b3: #303045;
        --t1: #e0e0e5; /* Higher contrast */
        --t2: #a0a0b0;
        --t3: #606075;
        --t4: #303040;
        --ok: #153a20;
        --okt: #40c060;
        --wa: #3a2a10;
        --wat: #c0a030;
        --da: #3a0a0a;
        --dat: #e04040;
        --dg: #500000;
        --dgt: #ff4040;
        --pu: #1a0a25;
        --put: #a060ff;
        --cyan: #0a2a35;
        --cyant: #50c0e0;
        --mono: 'Share Tech Mono', monospace;
        --sans: 'Noto Sans KR', sans-serif;
      }
      /* NEW ANIMATIONS */
      @keyframes blinkcursor {
        0%,
        49% {
          opacity: 1;
        }
        50%,
        100% {
          opacity: 0;
        }
      }
      @keyframes glitch {
        0%,
        100% {
          transform: none;
          opacity: 1;
        }
        7% {
          transform: translateX(-3px) skewX(-2deg);
          opacity: 0.8;
        }
        10% {
          transform: translateX(2px) skewX(1deg);
        }
        13% {
          transform: none;
          opacity: 1;
        }
        47% {
          transform: none;
        }
        50% {
          transform: translateX(1px);
          opacity: 0.9;
        }
        53% {
          transform: none;
          opacity: 1;
        }
      }
      @keyframes screenShake {
        0%,
        100% {
          transform: none;
        }
        10% {
          transform: translateX(-4px) translateY(2px);
        }
        30% {
          transform: translateX(3px) translateY(-1px);
        }
        50% {
          transform: translateX(-2px) translateY(1px);
        }
        70% {
          transform: translateX(2px);
        }
        90% {
          transform: translateX(-1px);
        }
      }
      @keyframes pulseGlow {
        0%,
        100% {
          box-shadow: 0 0 0 rgba(154, 32, 32, 0);
        }
        50% {
          box-shadow: 0 0 12px rgba(154, 32, 32, 0.3);
        }
      }
      @keyframes fadeSlideUp {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: none;
        }
      }
      @keyframes typeReveal {
        from {
          max-height: 0;
        }
        to {
          max-height: 500px;
        }
      }
      .shake {
        animation: screenShake 0.3s ease;
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        overflow: hidden;
        background: var(--bg);
        color: var(--t1);
        font-family: var(--mono);
        font-size: 13px;
        display: flex;
        flex-direction: column;
      }
      body::after {
        content: '';
        position: fixed;
        inset: 0;
        background: repeating-linear-gradient(
          0deg,
          transparent,
          transparent 2px,
          rgba(0, 0, 0, 0.05) 2px,
          rgba(0, 0, 0, 0.05) 3px
        );
        pointer-events: none;
        z-index: 9999;
      }
      body::before {
        content: '';
        position: fixed;
        inset: 0;
        background: radial-gradient(
          circle at 50% 50%,
          transparent 50%,
          rgba(0, 0, 0, 0.4) 100%
        );
        pointer-events: none;
        z-index: 9998;
      }
      .noise {
        display: none;
      }
      body::after {
        opacity: 0.02; /* Toned down scanlines */
      }

      /* SCROLLBAR */
      ::-webkit-scrollbar {
        width: 3px;
        height: 3px;
      }
      ::-webkit-scrollbar-track {
        background: transparent;
      }
      ::-webkit-scrollbar-thumb {
        background: var(--b2);
      }

      /* ── HEADER ── */
      #hdr {
        height: 64px; /* Slightly taller for padding */
        background: var(--bg2);
        border-bottom: 1px solid var(--b1);
        display: flex;
        align-items: center;
        padding: 12px 16px 0 16px; /* Increased top padding */
        gap: 0;
        flex-shrink: 0;
        position: relative;
        z-index: 100;
        box-sizing: border-box;
      }
      .htitle {
        font-size: 10px;
        letter-spacing: 4px;
        color: var(--t3);
        margin-right: 16px;
        /* margin-top removed to avoid clipping */
      }
      .hstat {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 0 12px;
        border-right: 1px solid var(--b1);
        height: 100%;
        justify-content: center;
        min-width: 65px;
      }
      .hstat:nth-child(2) {
        border-left: 1px solid var(--b1);
      }
      .hlabel {
        font-size: 9px;
        color: var(--t3);
        letter-spacing: 1px;
        margin-bottom: 1px;
      }
      .hval {
        font-size: 15px;
        font-weight: bold;
        transition: color 0.4s;
      }
      .hval.ok {
        color: var(--okt);
      }
      .hval.wa {
        color: var(--wat);
      }
      .hval.da {
        color: var(--dat);
      }
      .hval.pu {
        color: var(--put);
      }
      .hval.dim {
        color: var(--t2);
      }
      .hbar {
        height: 2px;
        width: 100%;
        background: var(--b1);
        margin-top: 2px;
        border-radius: 1px;
        overflow: hidden;
      }
      .hbar-f {
        height: 100%;
        border-radius: 1px;
        transition:
          width 0.5s,
          background 0.5s;
      }

      #dayclock {
        margin-left: auto;
        display: flex;
        align-items: center;
        gap: 12px;
      }
      #phasedis {
        font-size: 9px;
        color: var(--t3);
        letter-spacing: 2px;
      }
      #daydis {
        font-size: 17px;
        color: var(--t2);
        letter-spacing: 2px;
      }
      #charname {
        font-size: 10px;
        color: var(--t3);
        letter-spacing: 1px;
        border-left: 1px solid var(--b1);
        padding-left: 12px;
      }

      /* ── TIMER ── */
      #timerbar {
        height: 2px;
        background: var(--b1);
        flex-shrink: 0;
      }
      #timerfill {
        height: 100%;
        background: var(--ok);
        transition:
          width 1s linear,
          background 0.5s;
      }

      /* ── LAYOUT ── */
      #layout {
        display: flex;
        flex: 1;
        overflow: hidden;
        height: auto; /* Replaced manual calc with flex:1 */
      }

      /* ── LOG ── */
      #logpanel {
        flex: 1;
        overflow-y: auto;
        padding: 12px 16px;
        display: flex;
        flex-direction: column;
        gap: 0;
      }
      .lentry {
        display: flex;
        gap: 6px;
        padding: 2px 0 2px 8px;
        animation: fin 0.25s ease;
        border-left: 2px solid transparent;
        transition: border-color 0.2s;
      }
      .lentry.t-ev {
        border-left-color: #3a3018;
      }
      .lentry.t-da {
        border-left-color: #3a1010;
      }
      .lentry.t-ok {
        border-left-color: #1a3a1a;
      }
      .lentry.t-in {
        border-left-color: #1a2a3a;
      }
      .lentry.t-dg {
        border-left-color: #4a0000;
      }
      .lentry.t-dgt {
        border-left-color: #3a0000;
      }
      @keyframes fin {
        from {
          opacity: 0;
          transform: translateY(2px);
        }
        to {
          opacity: 1;
          transform: none;
        }
      }
      .lts {
        font-size: 9px;
        color: var(--t4);
        min-width: 24px;
        margin-top: 3px;
        flex-shrink: 0;
      }
      .ltxt {
        flex: 1;
        font-size: 12px;
        line-height: 1.7;
      }
      .ltxt.na {
        color: var(--t2);
      }
      .ltxt.ev {
        color: #6a5830;
      }
      .ltxt.da {
        color: #7a2828;
      }
      .ltxt.ok {
        color: #286a38;
      }
      .ltxt.in {
        color: #284858;
      }
      .ltxt.sy {
        color: var(--t3);
        font-size: 11px;
      }
      .ltxt.dg {
        color: #8b0000;
        font-weight: bold;
      }
      .ltxt.dgt {
        color: #660000;
        font-style: italic;
      }
      .ltxt.de {
        color: #4a0808;
      }
      .ltxt.sep {
        color: var(--t4);
        font-size: 10px;
        letter-spacing: 1px;
      }
      .lentry.gap {
        height: 6px;
      }

      /* ── RIGHT PANEL ── */
      #rpanel {
        width: 310px;
        display: flex;
        flex-direction: column;
        border-left: 1px solid var(--b1);
        overflow: hidden;
        flex-shrink: 0;
      }

      /* TABS */
      #tabs {
        display: flex;
        border-bottom: 1px solid var(--b1);
        flex-shrink: 0;
      }
      .tab {
        flex: 1;
        padding: 8px 0;
        font-size: 10px;
        letter-spacing: 1px;
        color: var(--t3);
        background: none;
        border: none;
        cursor: pointer;
        border-bottom: 2px solid transparent;
        transition: all 0.15s;
        font-family: var(--mono);
      }
      .tab:hover {
        color: var(--t1);
        background: var(--bg3);
      }
      .tab.active {
        color: var(--t1);
        border-bottom-color: var(--t2);
        background: var(--bg3);
      }

      /* TAB CONTENT */
      .tabcontent {
        display: none;
        flex: 1;
        overflow-y: auto;
        padding: 10px 12px;
        flex-direction: column;
        gap: 4px;
      }
      .tabcontent.active {
        display: flex;
      }

      /* SECTION TITLE */
      .stitle {
        font-size: 9px;
        color: var(--t3);
        letter-spacing: 2px;
        text-transform: uppercase;
        margin: 8px 0 4px;
        padding-bottom: 3px;
        border-bottom: 1px solid var(--b1);
      }
      .stitle:first-child {
        margin-top: 0;
      }

      /* WORLD ROW */
      .wrow {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 3px 0;
        border-bottom: 1px solid var(--b1);
      }
      .wkey {
        font-size: 11px;
        color: var(--t3);
      }
      .wval {
        font-size: 11px;
        color: var(--t2);
      }
      .wval.crit {
        color: var(--dat);
      }
      .wval.bad {
        color: var(--wat);
      }
      .wval.gd {
        color: var(--okt);
      }

      /* ACTION BTNS */
      .abtn {
        display: flex;
        align-items: center;
        gap: 6px;
        width: 100%;
        background: none;
        border: 1px solid transparent;
        color: var(--t2);
        font-family: var(--mono);
        font-size: 11px;
        padding: 5px 7px;
        text-align: left;
        cursor: pointer;
        transition: all 0.1s;
        border-radius: 2px;
      }
      .abtn:hover:not(:disabled) {
        background: var(--bg3);
        border-color: var(--b2);
        color: var(--t1);
      }
      .abtn:disabled {
        opacity: 0.2;
        cursor: not-allowed;
      }
      .bkey {
        color: var(--t3);
        font-size: 9px;
        background: var(--bg3);
        border: 1px solid var(--b1);
        padding: 1px 4px;
        border-radius: 2px;
        min-width: 18px;
        text-align: center;
      }
      .blabel {
        flex: 1;
      }
      .bcost {
        font-size: 9px;
        color: var(--t3);
        white-space: nowrap;
      }
      .bcost.neg {
        color: #4a2020;
      }
      .bcost.pos {
        color: #203a20;
      }
      .abtn.special {
        border-color: var(--pu);
        color: var(--put);
      }
      .abtn.special:hover {
        background: var(--pu);
      }

      /* SKILL TREE */
      .skill-row {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 4px 0;
        border-bottom: 1px solid var(--b1);
      }
      .skill-name {
        flex: 1;
        font-size: 11px;
        color: var(--t2);
      }
      .skill-lvl {
        font-size: 10px;
        color: var(--t3);
      }
      .skill-bar {
        flex: 1;
        height: 3px;
        background: var(--b1);
        border-radius: 2px;
        overflow: hidden;
      }
      .skill-fill {
        height: 100%;
        background: var(--put);
        border-radius: 2px;
        transition: width 0.4s;
      }
      .skill-up {
        font-size: 9px;
        padding: 2px 6px;
        background: none;
        border: 1px solid var(--pu);
        color: var(--put);
        cursor: pointer;
        font-family: var(--mono);
      }
      .skill-up:hover {
        background: var(--pu);
      }
      .skill-up:disabled {
        opacity: 0.2;
        cursor: not-allowed;
      }

      /* PEOPLE LIST */
      .pentry {
        padding: 5px 6px;
        border-bottom: 1px solid var(--b1);
        cursor: pointer;
        transition: background 0.1s;
      }
      .pentry:hover {
        background: var(--bg3);
      }
      .pname {
        font-size: 11px;
        color: var(--t1);
      }
      .pname.dead {
        color: var(--dat);
        text-decoration: line-through;
      }
      .pinfo {
        font-size: 10px;
        color: var(--t3);
        margin-top: 1px;
      }
      .prel {
        font-size: 10px;
        float: right;
      }
      .prel.enemy {
        color: var(--dat);
      }
      .prel.friend {
        color: var(--okt);
      }
      .prel.lover {
        color: #cc6080;
      }
      .prel.neutral {
        color: var(--t3);
      }

      /* MAP */
      #mapcontainer {
        padding: 8px;
        display: flex;
        flex-direction: column;
        gap: 4px;
        overflow-y: auto;
        flex: 1;
      }
      .maproom {
        padding: 8px 10px;
        border: 1px solid var(--b1);
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
        border-left: 3px solid var(--b1);
      }
      .maproom:hover {
        border-color: var(--b2);
        background: var(--bg3);
        transform: translateX(2px);
      }
      .maproom.current {
        border-color: var(--okt);
        border-left-color: var(--okt);
        background: rgba(42, 138, 74, 0.04);
      }
      .maproom.connected {
        border-left-color: var(--cyant);
      }
      .maproom.danger {
        border-color: var(--dat);
        border-left-color: var(--dat);
        animation: pulseGlow 2s ease infinite;
      }
      .maproom.locked {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .mroom-name {
        font-size: 11px;
        color: var(--t2);
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .mroom-name.current {
        color: var(--okt);
      }
      .mroom-info {
        font-size: 9px;
        color: var(--t3);
        margin-top: 2px;
      }
      .mroom-people {
        font-size: 9px;
        color: var(--t3);
        margin-top: 1px;
      }
      .mroom-dots {
        display: inline-flex;
        gap: 2px;
        margin-left: 4px;
      }
      .mroom-dots span {
        width: 4px;
        height: 4px;
        border-radius: 50%;
        background: var(--t3);
        display: inline-block;
      }
      .mroom-dots span.friendly {
        background: var(--okt);
      }
      .mroom-dots span.hostile {
        background: var(--dat);
      }
      .mroom-badge {
        position: absolute;
        right: 6px;
        top: 6px;
        font-size: 9px;
        padding: 1px 5px;
        border-radius: 2px;
      }
      .mroom-badge.safe {
        background: var(--ok);
        color: var(--okt);
      }
      .mroom-badge.unsafe {
        background: var(--da);
        color: var(--dat);
      }
      .mroom-badge.dg {
        background: var(--dg);
        color: var(--dgt);
      }

      /* MODAL */
      #modalbg {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 500;
        backdrop-filter: blur(3px);
      }
      #modalbg.h {
        display: none;
      }
      .mbox {
        background: var(--bg2);
        border: 1px solid var(--b2);
        padding: 24px 28px;
        max-width: 500px;
        min-width: 340px;
        max-height: 85vh;
        overflow-y: auto;
        animation: mfin 0.15s ease;
      }
      .mbox.dgbox {
        background: #060000;
        border-color: var(--dg);
      }
      @keyframes mfin {
        from {
          opacity: 0;
          transform: scale(0.97);
        }
        to {
          opacity: 1;
          transform: none;
        }
      }
      .mpretag {
        font-size: 9px;
        letter-spacing: 2px;
        color: var(--t3);
        margin-bottom: 3px;
      }
      .mtitle {
        font-size: 13px;
        color: var(--t1);
        letter-spacing: 1px;
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 1px solid var(--b1);
      }
      .mtitle.dg {
        color: var(--dgt);
        border-color: var(--dg);
      }
      .mbody {
        font-size: 12px;
        color: var(--t2);
        line-height: 1.9;
        margin-bottom: 16px;
        white-space: pre-wrap;
      }
      .mbody.dg {
        color: #662020;
      }
      .mchoices {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .mchoice {
        background: none;
        border: 1px solid var(--b1);
        color: var(--t2);
        font-family: var(--mono);
        font-size: 11px;
        padding: 8px 12px;
        text-align: left;
        cursor: pointer;
        transition: all 0.1s;
        line-height: 1.5;
      }
      .mchoice:hover {
        border-color: var(--b2);
        background: var(--bg3);
        color: var(--t1);
      }
      .mchoice.dg {
        border-color: #2a0000;
        color: #5a1818;
      }
      .mchoice.dg:hover {
        border-color: var(--dg);
        color: var(--dgt);
        background: #0a0000;
      }
      .mchoice:disabled {
        opacity: 0.2;
        cursor: not-allowed;
      }
      .msub {
        font-size: 10px;
        color: var(--t3);
        margin-top: 2px;
      }

      /* PHONE/DG UI */
      #dgphone {
        position: fixed;
        inset: 0;
        background: rgba(60, 0, 0, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 400;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.4s;
      }
      #dgphone.active {
        opacity: 1;
        pointer-events: all;
        animation: dgbg 2s ease infinite;
      }
      @keyframes dgbg {
        0%,
        100% {
          background: rgba(60, 0, 0, 0.12);
        }
        50% {
          background: rgba(60, 0, 0, 0.28);
        }
      }
      .dgbox2 {
        background: #060000;
        border: 1px solid #500000;
        padding: 22px 28px;
        max-width: 360px;
        animation: phshake 0.4s ease infinite;
      }
      @keyframes phshake {
        0%,
        100% {
          transform: none;
        }
        30% {
          transform: translateX(-2px) rotate(-0.3deg);
        }
        70% {
          transform: translateX(2px) rotate(0.3deg);
        }
      }
      .phdr {
        font-size: 9px;
        color: #500000;
        letter-spacing: 2px;
        margin-bottom: 4px;
      }
      .pname2 {
        font-size: 11px;
        color: #800000;
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 1px solid #300000;
      }
      .pmsg {
        color: #702020;
        font-size: 12px;
        line-height: 1.8;
        margin-bottom: 14px;
        font-style: italic;
      }
      .ptimer {
        font-size: 22px;
        color: #900000;
        text-align: center;
        margin-bottom: 14px;
        letter-spacing: 4px;
      }
      .pchb {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .pch {
        background: none;
        border: 1px solid #2a0000;
        color: #602020;
        font-family: var(--mono);
        font-size: 11px;
        padding: 7px 10px;
        text-align: left;
        cursor: pointer;
        transition: all 0.1s;
      }
      .pch:hover {
        border-color: #800000;
        color: #aa3030;
        background: #0a0000;
      }

      /* OVERLAY */
      #overlay {
        position: fixed;
        inset: 0;
        background: #000;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        transition: opacity 0.5s;
      }
      #overlay.h {
        opacity: 0;
        pointer-events: none;
      }
      .obox {
        max-width: 560px;
        border: 1px solid var(--b2);
        background: linear-gradient(180deg, var(--bg2) 0%, var(--bg) 100%);
        padding: 44px 52px;
        text-align: center;
        animation: fadeSlideUp 0.6s ease;
      }
      .obox.dead {
        border-color: #400000;
        background: linear-gradient(180deg, #0a0002 0%, #050000 100%);
      }
      .obox.win {
        border-color: #003300;
        background: linear-gradient(180deg, #000a02 0%, #000500 100%);
      }
      .opre {
        font-size: 9px;
        letter-spacing: 5px;
        color: var(--t3);
        margin-bottom: 12px;
        animation: fadeSlideUp 0.8s ease;
      }
      .otitle {
        font-size: 26px;
        letter-spacing: 6px;
        margin-bottom: 6px;
        animation: glitch 8s ease infinite;
      }
      .otitle.dead {
        color: #800000;
      }
      .otitle.win {
        color: var(--okt);
      }
      .osub {
        font-size: 9px;
        letter-spacing: 3px;
        color: var(--t3);
        margin-bottom: 28px;
      }
      .odesc {
        font-size: 12px;
        color: var(--t3);
        line-height: 2.2;
        text-align: left;
        margin-bottom: 28px;
        white-space: pre-wrap;
        padding: 0 8px;
        border-left: 1px solid var(--b1);
      }
      .obbg {
        display: flex;
        gap: 12px;
        justify-content: center;
        margin-top: 20px;
      }
      .obtn {
        background: none;
        border: 1px solid var(--b2);
        color: var(--t2);
        font-family: var(--mono);
        font-size: 12px;
        padding: 0 26px;
        height: 42px; /* Fixed height for uniformity */
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        letter-spacing: 2px;
        transition: all 0.2s;
        min-width: 140px;
      }
      .obtn:hover {
        border-color: var(--t2);
        color: var(--t1);
      }

      /* CHAR SELECT */
      .cgrid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 15px;
        max-height: 500px;
        overflow-y: auto;
        padding: 5px;
      }
      .ccard {
        border: 1px solid var(--b1);
        padding: 14px 16px;
        cursor: pointer;
        transition: all 0.25s;
        text-align: left;
        position: relative;
        overflow: hidden;
        background: var(--bg2);
      }
      .ccard::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 3px;
        height: 100%;
        background: var(--b2);
        transition:
          background 0.25s,
          width 0.25s;
      }
      .ccard:hover {
        border-color: var(--b3);
        background: var(--bg3);
        transform: translateX(2px);
      }
      .ccard:hover::before {
        background: var(--put);
      }
      .ccard.selected {
        border-color: var(--okt);
        background: rgba(42, 138, 74, 0.05);
      }
      .ccard.selected::before {
        background: var(--okt);
        width: 3px;
      }
      .cname {
        font-size: 13px;
        color: var(--t1);
        margin-bottom: 4px;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .cname .crole {
        font-size: 9px;
        color: var(--put);
        border: 1px solid var(--pu);
        padding: 1px 5px;
        letter-spacing: 1px;
      }
      .cdesc {
        font-size: 11px;
        color: var(--t3);
        line-height: 1.7;
      }
      .cstats {
        display: flex;
        gap: 10px;
        margin-top: 8px;
        flex-wrap: wrap;
      }
      .cst {
        font-size: 10px;
        color: var(--t3);
      }
      .cst span {
        color: var(--t2);
      }
      .cst.high span {
        color: var(--okt);
      }
      .ctag {
        display: inline-block;
        font-size: 9px;
        padding: 1px 6px;
        border: 1px solid var(--pu);
        color: var(--put);
        margin-top: 6px;
        margin-right: 3px;
      }
      .citems {
        margin-top: 6px;
        display: flex;
        gap: 4px;
        flex-wrap: wrap;
      }
      .citems span {
        font-size: 9px;
        color: var(--t3);
        background: var(--bg);
        border: 1px solid var(--b1);
        padding: 1px 5px;
      }

      /* TOAST */
      #toast {
        position: fixed;
        bottom: 52px;
        left: 50%;
        transform: translateX(-50%) translateY(8px);
        background: var(--bg3);
        border: 1px solid var(--b2);
        color: var(--t2);
        padding: 7px 18px;
        font-size: 11px;
        z-index: 600;
        opacity: 0;
        transition:
          opacity 0.25s,
          transform 0.25s;
        white-space: nowrap;
        pointer-events: none;
      }
      #toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
      #toast.err {
        border-color: var(--dat);
        color: var(--dat);
      }
      #toast.win {
        border-color: var(--okt);
        color: var(--okt);
      }
      #toast.dg {
        border-color: var(--dgt);
        color: var(--dgt);
        background: #040000;
      }

      /* INPUT */
      #inputarea {
        padding: 8px 14px;
        border-top: 1px solid var(--b1);
        display: flex;
        gap: 6px;
        align-items: center;
        background: var(--bg2);
        flex-shrink: 0;
      }
      #prompt {
        color: var(--t3);
        font-size: 12px;
      }
      #cmdinput {
        flex: 1;
        background: none;
        border: none;
        outline: none;
        color: var(--t1);
        font-family: var(--mono);
        font-size: 12px;
        caret-color: var(--t2);
      }
      #cmdinput::placeholder {
        color: var(--t4);
      }

      /* LEVEL UP FLASH */
      @keyframes lvlup {
        0% {
          opacity: 0;
          transform: translateY(-10px) scale(0.8);
        }
        20% {
          opacity: 1;
          transform: none;
        }
        80% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      .lvlflash {
        position: fixed;
        top: 60px;
        right: 20px;
        background: var(--pu);
        border: 1px solid var(--put);
        color: var(--put);
        padding: 8px 16px;
        font-size: 12px;
        z-index: 700;
        animation: lvlup 2.5s ease forwards;
        pointer-events: none;
      }

      /* PERSON DETAIL */
      .pdetail {
        padding: 8px 0;
      }
      .pdetrow {
        display: flex;
        justify-content: space-between;
        padding: 3px 0;
        border-bottom: 1px solid var(--b1);
        font-size: 11px;
      }
      .pdetkey {
        color: var(--t3);
      }
      .pdetval {
        color: var(--t2);
      }
      .pdesc2 {
        font-size: 11px;
        color: var(--t3);
        line-height: 1.7;
        margin: 8px 0;
        padding: 6px;
        border-left: 2px solid var(--b2);
      }
    </style>
  </head>
  <body>
    <!-- Noise removed -->
    <div id="overlay">
      <div class="obox" id="obox"></div>
    </div>

    <div id="modalbg" class="h">
      <div class="mbox" id="mbox">
        <div class="mpretag" id="mpretag"></div>
        <div class="mtitle" id="mtitle"></div>
        <div class="mbody" id="mbody"></div>
        <div class="mchoices" id="mchoices"></div>
      </div>
    </div>

    <div id="dgphone">
      <div class="dgbox2">
        <div class="phdr">// 새 메시지</div>
        <div class="pname2">박대겸 · 미확인</div>
        <div class="pmsg" id="dgmsg"></div>
        <div class="ptimer" id="dgtimer">20</div>
        <div class="pchb" id="dgchoices"></div>
      </div>
    </div>

    <div id="toast"></div>

    <div id="hdr">
      <div class="htitle">CENTENNIAL</div>
      <div class="hstat">
        <div class="hlabel">HP</div>
        <div class="hval dim" id="shp">100</div>
        <div class="hbar">
          <div
            class="hbar-f"
            id="bhp"
            style="width: 100%; background: #2a8a4a"
          ></div>
        </div>
      </div>
      <div class="hstat">
        <div class="hlabel">배고픔</div>
        <div class="hval ok" id="shu">0</div>
        <div class="hbar">
          <div
            class="hbar-f"
            id="bhu"
            style="width: 0%; background: #9a2020"
          ></div>
        </div>
      </div>
      <div class="hstat">
        <div class="hlabel">갈증</div>
        <div class="hval ok" id="sth">0</div>
        <div class="hbar">
          <div
            class="hbar-f"
            id="bth"
            style="width: 0%; background: #9a6020"
          ></div>
        </div>
      </div>
      <div class="hstat">
        <div class="hlabel">피로</div>
        <div class="hval ok" id="sfa">0</div>
        <div class="hbar">
          <div
            class="hbar-f"
            id="bfa"
            style="width: 0%; background: #7a5020"
          ></div>
        </div>
      </div>
      <div class="hstat">
        <div class="hlabel">심리</div>
        <div class="hval ok" id="ssa">100</div>
        <div class="hbar">
          <div
            class="hbar-f"
            id="bsa"
            style="width: 100%; background: #2a5a8a"
          ></div>
        </div>
      </div>
      <div class="hstat">
        <div class="hlabel">식량</div>
        <div class="hval dim" id="sfo">3</div>
      </div>
      <div class="hstat">
        <div class="hlabel">물</div>
        <div class="hval dim" id="swa">2</div>
      </div>
      <div class="hstat">
        <div class="hlabel">돈</div>
        <div class="hval dim" id="smo">500</div>
      </div>
      <div class="hstat">
        <div class="hlabel">평판</div>
        <div class="hval dim" id="sre">50</div>
      </div>
      <div class="hstat">
        <div class="hlabel">SP</div>
        <div class="hval pu" id="ssp">0</div>
      </div>
      <div id="dayclock">
        <div id="phasedis">아침</div>
        <div id="daydis">DAY 1</div>
        <div id="charname" style="display: none"></div>
      </div>
    </div>
    <div id="timerbar"><div id="timerfill" style="width: 100%"></div></div>

    <div id="layout">
      <div id="logpanel"></div>
      <div id="rpanel">
        <div id="tabs">
          <button class="tab active" onclick="switchTab('world')">현황</button>
          <button class="tab" onclick="switchTab('action')">행동</button>
          <button class="tab" onclick="switchTab('people')">인물</button>
          <button class="tab" onclick="switchTab('map')">지도</button>
          <button class="tab" onclick="switchTab('skill')">스킬</button>
        </div>

        <!-- WORLD TAB -->
        <div class="tabcontent active" id="tab-world">
          <div class="stitle">// 학교 현황</div>
          <div class="wrow">
            <span class="wkey">생존자</span
            ><span class="wval" id="wsurv">100명</span>
          </div>
          <div class="wrow">
            <span class="wkey">총 식량</span
            ><span class="wval" id="wfood">--</span>
          </div>
          <div class="wrow">
            <span class="wkey">식량 지속</span
            ><span class="wval" id="wdays">--</span>
          </div>
          <div class="wrow">
            <span class="wkey">치안</span
            ><span class="wval" id="worder">--</span>
          </div>
          <div class="wrow">
            <span class="wkey">온도</span
            ><span class="wval" id="wtemp">--</span>
          </div>
          <div class="wrow">
            <span class="wkey">대겸 위협</span
            ><span class="wval" id="wdg">침묵</span>
          </div>
          <div class="stitle">// 소지품</div>
          <div
            id="invgrid"
            style="display: flex; flex-wrap: wrap; gap: 3px; padding: 2px 0"
          ></div>
          <div class="stitle">// 세력</div>
          <div id="ganginfo" style="font-size: 11px; color: var(--t3)">
            없음
          </div>
          <div class="stitle">// 현재 위치</div>
          <div id="curloc" style="font-size: 11px; color: var(--okt)">
            교실 (3학년 B반)
          </div>
          <div class="stitle">// 상태 이상</div>
          <div id="statuses" style="font-size: 11px; color: var(--t3)">
            없음
          </div>
        </div>

        <!-- ACTION TAB -->
        <div class="tabcontent" id="tab-action">
          <div class="stitle">생존</div>
          <button class="abtn" data-a="eat">
            <span class="bkey">E</span><span class="blabel">식사</span
            ><span class="bcost neg">식량-1</span>
          </button>
          <button class="abtn" data-a="drink">
            <span class="bkey">W</span><span class="blabel">음료</span
            ><span class="bcost neg">물-1</span>
          </button>
          <button class="abtn" data-a="rest">
            <span class="bkey">R</span><span class="blabel">휴식</span
            ><span class="bcost">피로↓</span>
          </button>
          <button class="abtn" data-a="medic">
            <span class="bkey">M</span><span class="blabel">치료</span
            ><span class="bcost neg">구급키트</span>
          </button>
          <button class="abtn" data-a="hide">
            <span class="bkey">Z</span><span class="blabel">숨기/나오기</span
            ><span class="bcost">은폐</span>
          </button>
          <div class="stitle">탐색</div>
          <button class="abtn" data-a="explore">
            <span class="bkey">F</span><span class="blabel">현재 구역 탐색</span
            ><span class="bcost neg">피로+8</span>
          </button>
          <button class="abtn" data-a="move">
            <span class="bkey">V</span><span class="blabel">이동 (지도)</span
            ><span class="bcost">--</span>
          </button>
          <button class="abtn" data-a="scout">
            <span class="bkey">O</span><span class="blabel">정찰</span
            ><span class="bcost">정보</span>
          </button>
          <div class="stitle">사회</div>
          <button class="abtn" data-a="talk">
            <span class="bkey">T</span><span class="blabel">대화/접근</span
            ><span class="bcost">--</span>
          </button>
          <button class="abtn" data-a="trade">
            <span class="bkey">B</span><span class="blabel">거래</span
            ><span class="bcost">--</span>
          </button>
          <button class="abtn" data-a="guard">
            <span class="bkey">G</span><span class="blabel">경계</span
            ><span class="bcost pos">돈+60</span>
          </button>
          <button class="abtn" data-a="help">
            <span class="bkey">H</span><span class="blabel">돕기</span
            ><span class="bcost pos">평판+</span>
          </button>
          <button class="abtn" data-a="intel">
            <span class="bkey">I</span><span class="blabel">정보 수집</span
            ><span class="bcost">인맥 필요</span>
          </button>
          <div class="stitle">위험</div>
          <button class="abtn" data-a="rob">
            <span class="bkey">X</span><span class="blabel">약탈/협박</span
            ><span class="bcost neg">위험</span>
          </button>
          <button class="abtn" data-a="gang">
            <span class="bkey">N</span><span class="blabel">세력 관리</span
            ><span class="bcost">--</span>
          </button>
          <div class="stitle">제작</div>
          <button class="abtn" data-a="craft">
            <span class="bkey">C</span
            ><span class="blabel">제작/업그레이드</span
            ><span class="bcost">재료</span>
          </button>
          <button class="abtn special" data-a="charskill">
            <span class="bkey">Q</span><span class="blabel">특수 능력</span
            ><span class="bcost">SP필요</span>
          </button>
        </div>

        <!-- PEOPLE TAB -->
        <div class="tabcontent" id="tab-people">
          <div class="stitle">
            // 인물 목록 <span id="pplcount" style="color: var(--t3)"></span>
          </div>
          <div id="peoplelist"></div>
        </div>

        <!-- MAP TAB -->
        <div class="tabcontent" id="tab-map">
          <div id="mapcontainer"></div>
        </div>

        <!-- SKILL TAB -->
        <div class="tabcontent" id="tab-skill">
          <div class="stitle">
            // 스킬 포인트:
            <span id="spcount" style="color: var(--put)">0</span>
          </div>
          <div id="skilltree"></div>
        </div>
      </div>
    </div>
    <div id="inputarea">
      <span id="prompt">&gt;</span>
      <input
        id="cmdinput"
        type="text"
        placeholder="명령어 입력 또는 탭에서 행동 클릭... (?=도움말)"
        autocomplete="off"
        spellcheck="false"
      />
    </div>

    <script>
      // ═══════════════════════════════════════
      // DATA: PEOPLE
      // ═══════════════════════════════════════
      function makePeople() {
        const list = [
          // 깡패 무리
          {
            id: 'gangster1',
            name: '강태호',
            role: 'gangster',
            group: '불량배',
            hp: 100,
            maxhp: 100,
            alive: true,
            food: 5,
            money: 800,
            loc: 'gym',
            affinity: 0,
            trait: 'aggressive',
            desc: '체육관을 장악한 불량배 리더. 힘으로 모든 걸 해결한다.',
            gossip: true,
            trustworthy: false,
            loveInt: false,
            info: [],
          },
          {
            id: 'gangster2',
            name: '박찬민',
            role: 'gangster',
            group: '불량배',
            hp: 90,
            maxhp: 90,
            alive: true,
            food: 3,
            money: 400,
            loc: 'gym',
            affinity: 0,
            trait: 'follower',
            desc: '강태호의 부하. 말보다 주먹이 빠르다.',
            gossip: false,
            trustworthy: false,
            loveInt: false,
            info: [],
          },
          {
            id: 'gangster3',
            name: '손우진',
            role: 'gangster',
            group: '불량배',
            hp: 85,
            maxhp: 85,
            alive: true,
            food: 2,
            money: 300,
            loc: 'hallway2',
            affinity: 0,
            trait: 'greedy',
            desc: '불량배지만 혼자서는 약하다. 돈에 약하다.',
            gossip: true,
            trustworthy: false,
            loveInt: false,
            info: ['kitchen_stash'],
          },
          // 모범생
          {
            id: 'honor1',
            name: '정유진',
            role: 'honor',
            group: '모범생',
            hp: 70,
            maxhp: 70,
            alive: true,
            food: 4,
            money: 600,
            loc: 'classroom_a',
            affinity: 10,
            trait: 'smart',
            desc: '전교 1등. 논리적이고 냉정하지만 약한 사람을 돕는다.',
            gossip: false,
            trustworthy: true,
            loveInt: true,
            info: ['ration_schedule', 'exit_code'],
          },
          {
            id: 'honor2',
            name: '이찬호',
            role: 'honor',
            group: '모범생',
            hp: 65,
            maxhp: 65,
            alive: true,
            food: 3,
            money: 400,
            loc: 'library',
            affinity: 5,
            trait: 'cautious',
            desc: '도서관을 본거지로 삼은 전략가. 정보를 잘 분석한다.',
            gossip: false,
            trustworthy: true,
            loveInt: false,
            info: ['gang_plan', 'warehouse_key'],
          },
          {
            id: 'honor3',
            name: '박서윤',
            role: 'honor',
            group: '모범생',
            hp: 72,
            maxhp: 72,
            alive: true,
            food: 2,
            money: 300,
            loc: 'classroom_a',
            affinity: 8,
            trait: 'kind',
            desc: '착한 모범생. 하지만 이 상황에 너무 순진하다.',
            gossip: true,
            trustworthy: true,
            loveInt: true,
            info: ['daegyeom_past'],
          },
          // 유명한 학생 (인플루언서)
          {
            id: 'celeb1',
            name: '김나윤',
            role: 'celeb',
            group: '인플루언서',
            hp: 75,
            maxhp: 75,
            alive: true,
            food: 3,
            money: 1200,
            loc: 'rooftop',
            affinity: 0,
            trait: 'charismatic',
            desc: '전교에서 제일 유명한 학생. 팔로워가 2만명이었다. 지금은 의미없지만 사람들이 여전히 따른다.',
            gossip: true,
            trustworthy: false,
            loveInt: true,
            info: ['celeb_network'],
          },
          {
            id: 'celeb2',
            name: '오민재',
            role: 'celeb',
            group: '인플루언서',
            hp: 70,
            maxhp: 70,
            alive: true,
            food: 2,
            money: 900,
            loc: 'rooftop',
            affinity: -5,
            trait: 'narcissist',
            desc: '틱톡커. 상황을 자기 콘텐츠처럼 본다. 하지만 정보가 많다.',
            gossip: true,
            trustworthy: false,
            loveInt: false,
            info: ['daegyeom_location', 'supply_map'],
          },
          // 교사 (좋은)
          {
            id: 'teacher_good1',
            name: '김선희 교사',
            role: 'teacher_good',
            group: '교사',
            hp: 80,
            maxhp: 80,
            alive: true,
            food: 5,
            money: 1000,
            loc: 'office',
            affinity: 15,
            trait: 'protective',
            desc: '학생들을 진심으로 걱정하는 교사. 의료 지식이 있다.',
            gossip: false,
            trustworthy: true,
            loveInt: false,
            info: ['medical_supply', 'daegyeom_file'],
          },
          {
            id: 'teacher_good2',
            name: '박정우 교사',
            role: 'teacher_good',
            group: '교사',
            hp: 75,
            maxhp: 75,
            alive: true,
            food: 4,
            money: 800,
            loc: 'office',
            affinity: 10,
            trait: 'rational',
            desc: '이성적인 수학 교사. 상황 판단이 정확하다.',
            gossip: false,
            trustworthy: true,
            loveInt: false,
            info: ['exit_plan', 'ration_real'],
          },
          // 교사 (나쁜)
          {
            id: 'teacher_bad1',
            name: '최창수 교사',
            role: 'teacher_bad',
            group: '교사',
            hp: 85,
            maxhp: 85,
            alive: true,
            food: 8,
            money: 1500,
            loc: 'office',
            affinity: -20,
            trait: 'selfish',
            desc: '자기 식량만 챙기는 이기적인 교사. 학생들을 이용한다.',
            gossip: false,
            trustworthy: false,
            loveInt: false,
            info: ['hidden_stash_big', 'bribe_list'],
          },
          {
            id: 'teacher_bad2',
            name: '이수철 교사',
            role: 'teacher_bad',
            group: '교사',
            hp: 78,
            maxhp: 78,
            alive: true,
            food: 6,
            money: 1200,
            loc: 'hallway1',
            affinity: -15,
            trait: 'cruel',
            desc: '규율을 빌미로 학생들을 통제하려는 교사.',
            gossip: false,
            trustworthy: false,
            loveInt: false,
            info: ['blackmail_info'],
          },
          // 평범한 학생들
          {
            id: 'normal1',
            name: '윤소희',
            role: 'normal',
            group: '일반',
            hp: 80,
            maxhp: 80,
            alive: true,
            food: 2,
            money: 200,
            loc: 'classroom_b',
            affinity: 0,
            trait: 'scared',
            desc: '겁에 질려있는 학생. 보호해주면 충성한다.',
            gossip: true,
            trustworthy: true,
            loveInt: true,
            info: [],
          },
          {
            id: 'normal2',
            name: '한도현',
            role: 'normal',
            group: '일반',
            hp: 75,
            maxhp: 75,
            alive: true,
            food: 1,
            money: 100,
            loc: 'hallway1',
            affinity: 0,
            trait: 'desperate',
            desc: '식량이 없어 절망적인 상태. 뭐든 할 수 있다.',
            gossip: true,
            trustworthy: false,
            loveInt: false,
            info: ['trash_food'],
          },
          {
            id: 'normal3',
            name: '권지아',
            role: 'normal',
            group: '일반',
            hp: 82,
            maxhp: 82,
            alive: true,
            food: 3,
            money: 350,
            loc: 'classroom_b',
            affinity: 5,
            trait: 'observant',
            desc: '조용하지만 모든 걸 보고 있다. 정보가 많다.',
            gossip: false,
            trustworthy: true,
            loveInt: true,
            info: ['gang_weakness', 'night_movement'],
          },
          {
            id: 'normal4',
            name: '송민호',
            role: 'normal',
            group: '일반',
            hp: 88,
            maxhp: 88,
            alive: true,
            food: 2,
            money: 250,
            loc: 'hallway2',
            affinity: 0,
            trait: 'athletic',
            desc: '운동부 출신. 빠르고 강하지만 머리가 나쁘다.',
            gossip: false,
            trustworthy: true,
            loveInt: false,
            info: [],
          },
          {
            id: 'normal5',
            name: '최아름',
            role: 'normal',
            group: '일반',
            hp: 68,
            maxhp: 68,
            alive: true,
            food: 1,
            money: 150,
            loc: 'classroom_a',
            affinity: 3,
            trait: 'nurse',
            desc: '보건부장. 의료 지식이 있어서 도움이 된다.',
            gossip: false,
            trustworthy: true,
            loveInt: true,
            info: ['medical_use'],
          },
          {
            id: 'normal6',
            name: '임재원',
            role: 'normal',
            group: '일반',
            hp: 77,
            maxhp: 77,
            alive: true,
            food: 4,
            money: 500,
            loc: 'cafeteria',
            affinity: -5,
            trait: 'hoarder',
            desc: '식량을 몰래 모아두고 있다. 신뢰하기 어렵다.',
            gossip: true,
            trustworthy: false,
            loveInt: false,
            info: ['hoard_location'],
          },
          {
            id: 'normal7',
            name: '강지수',
            role: 'normal',
            group: '일반',
            hp: 72,
            maxhp: 72,
            alive: true,
            food: 2,
            money: 200,
            loc: 'hallway1',
            affinity: 7,
            trait: 'loyal',
            desc: '한번 친해지면 끝까지 돕는다.',
            gossip: false,
            trustworthy: true,
            loveInt: true,
            info: [],
          },
          {
            id: 'normal8',
            name: '류승현',
            role: 'normal',
            group: '일반',
            hp: 80,
            maxhp: 80,
            alive: true,
            food: 3,
            money: 300,
            loc: 'gym',
            affinity: -10,
            trait: 'opportunist',
            desc: '기회주의자. 강한 편에 붙는다.',
            gossip: true,
            trustworthy: false,
            loveInt: false,
            info: ['gangster_plan'],
          },
          // 틱톡커
          {
            id: 'tiktoker1',
            name: '홍지훈',
            role: 'tiktoker',
            group: '인플루언서',
            hp: 73,
            maxhp: 73,
            alive: true,
            food: 2,
            money: 700,
            loc: 'rooftop',
            affinity: 0,
            trait: 'documenter',
            desc: '이 상황을 전부 기록하고 있다. 목격한 게 많다.',
            gossip: true,
            trustworthy: false,
            loveInt: false,
            info: ['daegyeom_sighting', 'kitchen_route'],
          },
          // 학생회
          {
            id: 'council1',
            name: '문하영',
            role: 'council',
            group: '학생회',
            hp: 76,
            maxhp: 76,
            alive: true,
            food: 4,
            money: 600,
            loc: 'classroom_a',
            affinity: 12,
            trait: 'leader',
            desc: '학생회장. 조직력이 있고 사람들이 따른다.',
            gossip: false,
            trustworthy: true,
            loveInt: false,
            info: ['ration_system', 'alliance_info'],
          },
          {
            id: 'council2',
            name: '최예린',
            role: 'council',
            group: '학생회',
            hp: 70,
            maxhp: 70,
            alive: true,
            food: 3,
            money: 400,
            loc: 'classroom_a',
            affinity: 8,
            trait: 'diplomat',
            desc: '학생회 부회장. 중재를 잘 한다.',
            gossip: false,
            trustworthy: true,
            loveInt: true,
            info: ['conflict_info'],
          },
          // 수상한 학생
          {
            id: 'sus1',
            name: '백현우',
            role: 'suspect',
            group: '독립',
            hp: 85,
            maxhp: 85,
            alive: true,
            food: 6,
            money: 1000,
            loc: 'warehouse',
            affinity: -5,
            trait: 'mysterious',
            desc: '어디서 그렇게 많은 물자를 구했는지 모른다. 대겸과 가까웠다는 소문이 있다.',
            gossip: false,
            trustworthy: false,
            loveInt: false,
            info: ['daegyeom_plan', 'secret_tunnel'],
          },
          // 무기 있는 학생
          {
            id: 'armed1',
            name: '정태산',
            role: 'armed',
            group: '독립',
            hp: 95,
            maxhp: 95,
            alive: true,
            food: 4,
            money: 600,
            loc: 'hallway2',
            affinity: -8,
            trait: 'paranoid',
            desc: '자체 제작 무기를 가지고 있다. 아무도 안 믿는다.',
            gossip: false,
            trustworthy: false,
            loveInt: false,
            info: [],
          },
          // 아픈 학생
          {
            id: 'sick1',
            name: '이나리',
            role: 'sick',
            group: '일반',
            hp: 40,
            maxhp: 80,
            alive: true,
            food: 1,
            money: 100,
            loc: 'classroom_b',
            affinity: 5,
            trait: 'sick',
            desc: '심하게 아프다. 약이 필요하다. 그의 가족 이야기를 알고 있다.',
            gossip: true,
            trustworthy: true,
            loveInt: false,
            info: ['sympathy_info', 'daegyeom_childhood'],
          },
          // 교장
          {
            id: 'principal',
            name: '교장 선생님',
            role: 'principal',
            group: '교사',
            hp: 80,
            maxhp: 80,
            alive: true,
            food: 10,
            money: 2000,
            loc: 'office',
            affinity: 5,
            trait: 'authority',
            desc: '학교의 최고 권위자. 하지만 상황 통제력을 잃어가고 있다.',
            gossip: false,
            trustworthy: true,
            loveInt: false,
            info: ['school_secret', 'rationing_control'],
          },
          // 대겸
          {
            id: 'daegyeom',
            name: '박대겸',
            role: 'villain',
            group: '독립',
            hp: 100,
            maxhp: 100,
            alive: true,
            food: 20,
            money: 5000,
            loc: 'warehouse',
            affinity: -100,
            trait: 'villain',
            desc: '이 모든 일의 배후. 그가 왜 이러는지 아무도 모른다.',
            gossip: false,
            trustworthy: false,
            loveInt: false,
            info: ['everything'],
          },
          // 신규 캐릭터들
          {
            id: 'tiffany',
            name: '티파니',
            role: 'celeb',
            group: '인플루언서',
            hp: 85,
            maxhp: 85,
            alive: true,
            food: 4,
            money: 1200,
            loc: 'rooftop',
            affinity: 0,
            trait: 'charismatic',
            desc: '학교의 퀸카. 여러 남자애들과 복잡한 관계를 맺고 있다.',
            gossip: true,
            trustworthy: false,
            loveInt: true,
            info: ['boy_secrets'],
          },
          {
            id: 'naip',
            name: '나입',
            role: 'merchant',
            group: '독립',
            hp: 90,
            maxhp: 90,
            alive: true,
            food: 6,
            money: 3000,
            loc: 'hallway1',
            affinity: 5,
            trait: 'merchant',
            desc: '모든 것을 파는 남자. 그의 가방에는 무엇이든 들어있다.',
            gossip: true,
            trustworthy: true,
            loveInt: false,
            info: ['rare_sources'],
          },
          {
            id: 'rednic',
            name: '레드닉',
            role: 'thief',
            group: '독립',
            hp: 80,
            maxhp: 80,
            alive: true,
            food: 2,
            money: 500,
            loc: 'warehouse',
            affinity: -15,
            trait: 'stealthy',
            desc: '물건을 훔치는 데 천부적인 소질을 가진 학생.',
            gossip: true,
            trustworthy: false,
            loveInt: false,
            info: ['steal_targets'],
          },
          {
            id: 'rako',
            name: '라코',
            role: 'rich',
            group: '유학생',
            hp: 100,
            maxhp: 100,
            alive: true,
            food: 8,
            money: 5000,
            loc: 'office',
            affinity: 10,
            trait: 'wealthy',
            desc: '일본에서 온 부잣집 아들. 타이치와 매우 절친하다.',
            gossip: false,
            trustworthy: true,
            loveInt: false,
            info: ['rich_info'],
          },
          {
            id: 'jerry',
            name: '제리',
            role: 'rich',
            group: '유학생',
            hp: 95,
            maxhp: 95,
            alive: true,
            food: 8,
            money: 4500,
            loc: 'office',
            affinity: 10,
            trait: 'wealthy',
            desc: '중국에서 온 부잣집 딸. 라코의 여자친구이자 타이치와 친하다.',
            gossip: false,
            trustworthy: true,
            loveInt: true,
            info: ['rich_info2'],
          },
          {
            id: 'cat',
            name: '고양이',
            role: 'animal',
            group: '동물',
            hp: 40,
            maxhp: 40,
            alive: true,
            food: 0,
            money: 0,
            loc: 'science_lab',
            affinity: 20,
            trait: 'agile',
            desc: '과학실에 사는 길고양이. 쥐를 잘 잡는다.',
            gossip: false,
            trustworthy: false,
            loveInt: false,
            info: [],
          },
        ];
        // 나머지 73명은 익명의 NPC
        const roles = [
          'student_m',
          'student_f',
          'student_m',
          'student_f',
          'student_m',
        ];
        const lastnames = [
          '김',
          '이',
          '박',
          '최',
          '정',
          '한',
          '오',
          '조',
          '윤',
          '장',
        ];
        const firstnames = [
          '지우',
          '민준',
          '서연',
          '도현',
          '수아',
          '재원',
          '하은',
          '준혁',
          '나영',
          '현우',
        ];
        for (let i = 0; i < 73; i++) {
          const ln = lastnames[i % lastnames.length];
          const fn = firstnames[Math.floor(Math.random() * firstnames.length)];
          const locs = [
            'classroom_a',
            'classroom_b',
            'hallway1',
            'hallway2',
            'gym',
            'cafeteria',
            'rooftop',
            'library',
          ];
          list.push({
            id: 'anon' + i,
            name: ln + fn + (i + 1),
            role: roles[i % roles.length],
            group: '일반',
            hp: Math.floor(Math.random() * 40 + 50),
            maxhp: Math.floor(Math.random() * 40 + 60),
            hunger: 20 + r(10), // Initialize hunger
            thirst: 20 + r(10), // Initialize thirst
            alive: Math.random() > 0.05,
            food: 0,
            money: Math.floor(Math.random() * 300),
            loc: locs[Math.floor(Math.random() * locs.length)],
            affinity: Math.floor(Math.random() * 20 - 5),
            trait: 'normal',
            desc: '평범한 학생.',
            gossip: Math.random() > 0.5,
            trustworthy: Math.random() > 0.4,
            loveInt: false,
            info: [],
            inventory: [
              ...Array(Math.floor(Math.random() * 2))
                .fill(null)
                .map(() => 'food_ration'),
              ...Array(Math.floor(Math.random() * 2))
                .fill(null)
                .map(() => 'water_bottle'),
            ],
          });
        }
        // Convert food field to inventory for named NPCs
        list.forEach((p) => {
          if (!p.inventory) {
            p.inventory = [];
            const fc = Math.min(p.food || 0, 5);
            for (let j = 0; j < fc; j++) p.inventory.push('food_ration');
            const wc = Math.max(1, Math.floor(fc * 0.5));
            for (let j = 0; j < wc; j++) p.inventory.push('water_bottle');
            // Role-specific bonus items
            if (p.role === 'gangster')
              p.inventory.push(r(2) === 0 ? 'knife' : 'pipe');
            if (p.role === 'teacher_good') p.inventory.push('first_aid');
            if (p.role === 'teacher_bad')
              p.inventory.push('canned_food', 'canned_food');
            if (p.role === 'villain') {
              p.inventory = [
                'food_ration',
                'food_ration',
                'food_ration',
                'food_ration',
                'food_ration',
                'canned_food',
                'canned_food',
                'canned_food',
                'water_bottle',
                'water_bottle',
                'water_bottle',
                'knife',
                'sleeping_pills',
              ];
            }
            if (p.role === 'suspect') p.inventory.push('canned_food', 'rope');
            if (p.role === 'merchant')
              p.inventory.push('gas_mask', 'radio', 'canned_food', 'lock');
            if (p.role === 'thief') p.inventory.push('knife', 'lighter');
            if (p.role === 'rich')
              p.inventory.push(
                'canned_food',
                'canned_food',
                'water_bottle',
                'water_bottle',
              );
            if (p.role === 'animal') p.inventory = [];
          }
        });
        // Initial Affinities
        const rako = list.find((x) => x.id === 'rako');
        const jerry = list.find((x) => x.id === 'jerry');
        const taichi = list.find((x) => x.id === 'taichi');
        if (rako && jerry) {
          rako.affinity_jerry = 100;
          jerry.affinity_rako = 100;
        }
        if (taichi && rako && jerry) {
          taichi.affinity_rako = 80;
          taichi.affinity_jerry = 80;
          rako.affinity_taichi = 80;
          jerry.affinity_taichi = 80;
        }
        return list;
      }

      // ═══════════════════════════════════════
      // DATA: ROOMS / MAP
      // ═══════════════════════════════════════
      const ROOMS = {
        classroom_a: {
          name: '3학년 A반',
          desc: '원래 너의 교실. 사람들이 모여있다.',
          safe: true,
          searchable: true,
          food: 1,
          items: ['notebook'],
          dangerLevel: 0,
          hideSpot: true,
          hideChance: 0.6,
        },
        classroom_b: {
          name: '3학년 B반',
          desc: '이웃 교실. 아픈 학생이 있다.',
          safe: true,
          searchable: true,
          food: 1,
          items: [],
          dangerLevel: 0,
          hideSpot: true,
          hideChance: 0.6,
        },
        hallway1: {
          name: '1층 복도',
          desc: '교장실과 교무실이 있다. 교사들이 모인다.',
          safe: true,
          searchable: true,
          food: 0,
          items: ['lighter'],
          dangerLevel: 1,
          hideSpot: false,
          hideChance: 0,
        },
        hallway2: {
          name: '2층 복도',
          desc: '불량배들이 돌아다닌다. 위험하다.',
          safe: false,
          searchable: true,
          food: 0,
          items: ['pipe'],
          dangerLevel: 3,
          hideSpot: false,
          hideChance: 0,
        },
        gym: {
          name: '체육관',
          desc: '불량배 무리가 장악했다. 식량이 많다.',
          safe: false,
          searchable: true,
          food: 3,
          items: ['bat', 'rope'],
          dangerLevel: 4,
          hideSpot: false,
          hideChance: 0,
        },
        cafeteria: {
          name: '급식실',
          desc: '식량 창고. 여러 세력이 노리고 있다.',
          safe: false,
          searchable: true,
          food: 5,
          items: ['first_aid'],
          dangerLevel: 3,
          hideSpot: true,
          hideChance: 0.5,
        },
        office: {
          name: '교무실',
          desc: '교사들이 있다. 금고가 있다는 소문.',
          safe: true,
          searchable: true,
          food: 2,
          items: ['antibiotics', 'sleeping_pills', 'secret_tunnel_note'],
          dangerLevel: 1,
          hideSpot: true,
          hideChance: 0.65,
        },
        rooftop: {
          name: '옥상',
          desc: '탈출 가능성을 보기 좋다. 인플루언서들이 있다.',
          safe: true,
          searchable: false,
          food: 0,
          items: ['rope'],
          dangerLevel: 0,
          hideSpot: false,
          hideChance: 0,
        },
        library: {
          name: '도서관',
          desc: '조용하다. 정보를 얻기 좋다.',
          safe: true,
          searchable: true,
          food: 0,
          items: ['daegyeom_note'],
          dangerLevel: 0,
          hideSpot: true,
          hideChance: 0.8,
        },
        warehouse: {
          name: '창고',
          desc: '학교 지하 창고. 뭔가 숨겨져 있다.',
          safe: false,
          searchable: true,
          food: 4,
          items: ['knife', 'warm_clothes', 'antibiotics'],
          dangerLevel: 2,
          hideSpot: true,
          hideChance: 0.7,
        },
        science_lab: {
          name: '과학실',
          desc: '화학 약품이 있다. 특별한 제작이 가능하다.',
          safe: true,
          searchable: true,
          food: 0,
          items: ['chemicals'],
          dangerLevel: 1,
          hideSpot: true,
          hideChance: 0.65,
        },
        bathroom: {
          name: '화장실',
          desc: '숨기 좋다. 빗물을 받을 수 있다.',
          safe: true,
          searchable: false,
          food: 0,
          items: [],
          dangerLevel: 0,
          hideSpot: true,
          hideChance: 0.9,
        },
      };

      const ROOM_CONNECTIONS = {
        classroom_a: ['classroom_b', 'hallway1'],
        classroom_b: ['classroom_a', 'hallway2', 'bathroom'],
        hallway1: ['classroom_a', 'office', 'cafeteria'],
        hallway2: ['classroom_b', 'gym', 'hallway1'],
        gym: ['hallway2', 'warehouse'],
        cafeteria: ['hallway1', 'warehouse'],
        office: ['hallway1'],
        rooftop: ['hallway2'],
        library: ['hallway1'],
        warehouse: ['gym', 'cafeteria', 'science_lab'],
        science_lab: ['warehouse'],
        bathroom: ['classroom_b'],
      };

      // ═══════════════════════════════════════
      // DATA: ITEMS
      // ═══════════════════════════════════════
      const ITEMS = {
        food_ration: {
          name: '식량 배급',
          icon: '🍙',
          desc: '배고픔 해소',
          price: 100,
        },
        water_bottle: { name: '물', icon: '💧', desc: '갈증 해소', price: 60 },
        canned_food: {
          name: '통조림',
          icon: '🥫',
          desc: '고급 식량. HP+12',
          price: 180,
        },
        first_aid: {
          name: '구급키트',
          icon: '🩹',
          desc: 'HP+30, 부상 치료',
          price: 250,
        },
        antibiotics: {
          name: '항생제',
          icon: '💊',
          desc: '감염/병 치료',
          price: 300,
        },
        sleeping_pills: {
          name: '수면제',
          icon: '💊',
          desc: '대겸 최종 대결 선택지',
          price: 200,
        },
        knife: {
          name: '과도',
          icon: '🔪',
          desc: '무기. 약탈 성공률+',
          price: 200,
        },
        pipe: { name: '파이프', icon: '🔩', desc: '무기. 공격력+', price: 150 },
        bat: {
          name: '야구방망이',
          icon: '🏏',
          desc: '강력한 무기',
          price: 250,
        },
        rope: { name: '밧줄', icon: '🪢', desc: '탈출 선택지 추가', price: 80 },
        lighter: { name: '라이터', icon: '🔥', desc: '불 피우기', price: 40 },
        warm_clothes: {
          name: '두꺼운 옷',
          icon: '🧥',
          desc: '추위 저항',
          price: 180,
        },
        lock: { name: '자물쇠', icon: '🔒', desc: '야간 도난 방지', price: 90 },
        daegyeom_note: {
          name: '대겸의 메모',
          icon: '📝',
          desc: '??? 최후 대결 선택지',
          price: 500,
        },
        chemicals: {
          name: '화학약품',
          icon: '⚗️',
          desc: '특수 제작 재료',
          price: 120,
        },
        notebook: {
          name: '노트',
          icon: '📓',
          desc: '특이한 내용이 적혀있다',
          price: 30,
        },
        gas_mask: {
          name: '방독면',
          icon: '😷',
          desc: '화학 가스 방어',
          price: 220,
        },
        molotov: {
          name: '화염병',
          icon: '🍾',
          desc: '전투시 사용',
          price: 180,
        },
        radio: {
          name: '라디오',
          icon: '📻',
          desc: '외부 정보 수신',
          price: 300,
        },
        phone: {
          name: '스마트폰',
          icon: '📱',
          desc: '배터리 잔량: 12%',
          price: 400,
        },
        secret_tunnel_note: {
          name: '비밀 통로 메모',
          icon: '📜',
          desc: '창고 바닥 아래에 길이 있다는 메모다.',
          price: 300,
        },
      };

      // ═══════════════════════════════════════
      // DATA: SKILLS
      // ═══════════════════════════════════════
      const SKILL_DEFS = {
        strength: {
          name: '체력',
          maxlv: 5,
          desc: '최대HP+15/레벨, 전투 성공률+',
          icon: '💪',
        },
        agility: {
          name: '민첩',
          maxlv: 5,
          desc: '도망 성공률+, 탐색 속도+',
          icon: '🏃',
        },
        social: {
          name: '사교',
          maxlv: 5,
          desc: '호감도 상승속도+, 거래 가격↓',
          icon: '🗣️',
        },
        intel: {
          name: '지력',
          maxlv: 5,
          desc: '정보 신뢰도 판별+, 거짓말 탐지',
          icon: '🧠',
        },
        survival: {
          name: '생존',
          maxlv: 5,
          desc: '식량 소비↓, 탐색 성공률+',
          icon: '🌿',
        },
        stealth: {
          name: '은신',
          maxlv: 5,
          desc: '야간 도난 방지+, 잠입 성공+',
          icon: '👤',
        },
        medical: {
          name: '의료',
          maxlv: 3,
          desc: '치료 효율+, 약 제작',
          icon: '⚕️',
        },
        combat: {
          name: '전투',
          maxlv: 3,
          desc: '무기 데미지+, 방어력+',
          icon: '⚔️',
        },
      };

      // ═══════════════════════════════════════
      // INFO DATABASE (일부는 거짓!)
      // ═══════════════════════════════════════
      const INFO_DB = {
        kitchen_stash: {
          text: '급식실 냉장고 뒤에 식량 5개가 숨겨져 있다.',
          true: true,
          src: 'gangster3',
        },
        ration_schedule: {
          text: '배급은 오전 9시, 오후 3시 두 번이다. 하지만 내일부터 줄인다.',
          true: true,
          src: 'honor1',
        },
        exit_code: {
          text: '학교 뒷문 비밀번호는 2809다.',
          true: false,
          src: 'honor1',
        }, // 거짓!
        gang_plan: {
          text: '강태호가 오늘 밤 급식실을 습격할 계획이다.',
          true: true,
          src: 'honor2',
        },
        warehouse_key: {
          text: '창고 열쇠는 최창수 교사가 갖고 있다.',
          true: true,
          src: 'honor2',
        },
        daegyeom_past: {
          text: '박대겸은 작년에 가족이 사고로 죽었다. 그 이후 이상해졌다.',
          true: true,
          src: 'honor3',
        },
        celeb_network: {
          text: '김나윤은 모든 세력과 연결되어 있다. 그녀를 통하면 정보를 빠르게 얻는다.',
          true: true,
          src: 'celeb1',
        },
        daegyeom_location: {
          text: '대겸을 어제 창고 근처에서 봤다.',
          true: true,
          src: 'celeb2',
        },
        supply_map: {
          text: '비상 물자가 과학실에 숨겨져 있다.',
          true: false,
          src: 'celeb2',
        }, // 거짓!
        medical_supply: {
          text: '보건실에 구급키트 3개가 남아있다.',
          true: true,
          src: 'teacher_good1',
        },
        daegyeom_file: {
          text: '대겸의 생활기록부에 심리 상담 기록이 있다.',
          true: true,
          src: 'teacher_good1',
        },
        exit_plan: {
          text: '3일 뒤 군부대가 학교를 진입할 계획이다.',
          true: true,
          src: 'teacher_good2',
        },
        ration_real: {
          text: '실제 식량은 약 800개. 3일이면 바닥난다.',
          true: true,
          src: 'teacher_good2',
        },
        hidden_stash_big: {
          text: '창고 지하에 식량 20개와 돈 5만원이 숨겨져 있다.',
          true: false,
          src: 'teacher_bad1',
        }, // 거짓! (함정)
        bribe_list: {
          text: '최창수 교사는 일부 학생들에게 뇌물을 받고 식량을 더 줬다.',
          true: true,
          src: 'teacher_bad1',
        },
        blackmail_info: {
          text: '이수철 교사가 특정 학생을 협박하고 있다.',
          true: true,
          src: 'teacher_bad2',
        },
        gang_weakness: {
          text: '강태호는 새벽 2시에 혼자 순찰한다. 그때 체육관은 비어있다.',
          true: true,
          src: 'normal3',
        },
        night_movement: {
          text: '대겸은 밤에만 활동한다.',
          true: true,
          src: 'normal3',
        },
        gangster_plan: {
          text: '불량배들이 내일 학생회를 공격할 것이다.',
          true: false,
          src: 'normal8',
        }, // 거짓!
        daegyeom_sighting: {
          text: '대겸이 교장실에서 나오는 걸 봤다. 어제 밤.',
          true: true,
          src: 'tiktoker1',
        },
        kitchen_route: {
          text: '급식실 천장 환기구를 통해 들어갈 수 있다.',
          true: true,
          src: 'tiktoker1',
        },
        ration_system: {
          text: '학생회가 공정한 배급 시스템을 만들려 한다.',
          true: true,
          src: 'council1',
        },
        alliance_info: {
          text: '학생회, 모범생 그룹, 좋은 교사들이 연합을 논의 중이다.',
          true: true,
          src: 'council1',
        },
        conflict_info: {
          text: '세 세력이 충돌 직전이다. 누군가 중재하지 않으면 피를 본다.',
          true: true,
          src: 'council2',
        },
        daegyeom_plan: {
          text: '대겸은 모든 식량이 바닥나기를 기다리고 있다. 혼란이 목적이다.',
          true: true,
          src: 'sus1',
        },
        secret_tunnel: {
          text: '창고 뒤에 외부로 연결된 환기구가 있다.',
          true: true,
          src: 'sus1',
        },
        hoard_location: {
          text: '임재원이 화장실 천장에 식량 7개를 숨겨뒀다.',
          true: true,
          src: 'normal6',
        },
        trash_food: {
          text: '급식실 쓰레기통 뒤에 아직 먹을 수 있는 식량이 있다.',
          true: true,
          src: 'normal2',
        },
        sympathy_info: {
          text: '이나리는 대겸과 초등학교 동창이다.',
          true: true,
          src: 'sick1',
        },
        daegyeom_childhood: {
          text: '대겸은 이 학교 교사 중 한 명을 증오한다. 그 교사가 대겸 가족의 죽음과 관련있다.',
          true: true,
          src: 'sick1',
        },
        medical_use: {
          text: '항생제를 항생제끼리 섞으면 효과가 두 배가 된다.',
          true: false,
          src: 'normal5',
        }, // 거짓!
        school_secret: {
          text: '이 봉쇄는 사고가 아니다. 정부가 의도적으로 봉쇄했다.',
          true: true,
          src: 'principal',
        },
        rationing_control: {
          text: '교장은 식량의 30%를 별도 보관하고 있다.',
          true: true,
          src: 'principal',
        },
        // 22 NEW RUMORS
        dg_secret_1: {
          text: '대겸은 지하실에서 매일 누군가와 대화하는 소리가 들린다.',
          true: true,
          src: 'normal1',
        },
        dg_secret_2: {
          text: '사실 대겸은 학교 밖으로 나가는 길을 이미 알고 있다.',
          true: false,
          src: 'normal2',
        },
        secret_tunnel_2: {
          text: '비밀 통로는 창고뿐만 아니라 과학실 배수구와도 연결되어 있다.',
          true: true,
          src: 'sus2',
        },
        teacher_plot: {
          text: '최창수 교사는 밤마다 학생들의 식량을 빼돌려 금고에 채우고 있다.',
          true: true,
          src: 'normal3',
        },
        relief_supply: {
          text: '구조 헬기가 옥상이 아닌 운동장에 물자를 투하할 계획이다.',
          true: false,
          src: 'tiktoker2',
        },
        poison_water: {
          text: '화장실 빗물 탱크에 누군가 독을 탔다는 소문이 있다.',
          true: false,
          src: 'sick2',
        },
        dg_weakness_2: {
          text: '대겸은 향수 냄새에 극도로 민감해서 맡으면 기침을 멈추지 못한다.',
          true: true,
          src: 'celeb3',
        },
        hidden_weapon: {
          text: '방송실 캐비닛 뒤에 전기충격기가 숨겨져 있다.',
          true: true,
          src: 'normal4',
        },
        missing_student: {
          text: '실종된 줄 알았던 학생 중 하나가 벽 사이에 숨어 살고 있다.',
          true: true,
          src: 'normal5',
        },
        phone_signal: {
          text: '교무실 특정 위치에서만 외부와 짧게 통화가 가능하다.',
          true: true,
          src: 'normal6',
        },
        gang_betrayal: {
          text: '부두목격인 불량배가 강태호를 몰아낼 음모를 꾸미고 있다.',
          true: true,
          src: 'gangster1',
        },
        medicine_stash: {
          text: '양호실 바닥 타일 하나가 들리는데, 그 아래 항생제가 가득하다.',
          true: true,
          src: 'normal7',
        },
        dg_past_2: {
          text: '대겸의 부모님은 이 학교의 비리 때문에 돌아가셨다.',
          true: true,
          src: 'normal8',
        },
        night_rule: {
          text: '밤 12시 이후에 복도를 돌아다니면 대겸보다 더 무서운 것을 보게 된다.',
          true: false,
          src: 'normal9',
        },
        secret_exit_3: {
          text: "도서실 '생존' 테마 구역의 특정 책을 당기면 지하 통로가 열린다.",
          true: false,
          src: 'normal10',
        },
        principal_safe: {
          text: '교장실 금고 비밀번호는 그의 결혼 기념일인 0521이다.',
          true: true,
          src: 'normal1',
        },
        food_poisoning: {
          text: '한 달 유통기한이 지난 통조림을 먹으면 즉사할 수도 있다.',
          true: false,
          src: 'sick3',
        },
        dg_companion: {
          text: '대겸은 혼자가 아니다. 그를 돕는 미친 학생이 한 명 더 있다.',
          true: true,
          src: 'normal2',
        },
        rescue_signal: {
          text: '거울 3개를 이용해서 햇빛을 반사하면 외부에 구조 신호를 보낼 수 있다.',
          true: true,
          src: 'normal3',
        },
        secret_fountain: {
          text: '학교 뒤뜰의 분수대는 사실 비상 저수조와 연결되어 있다.',
          true: true,
          src: 'normal4',
        },
        infected_warning: {
          text: '상처를 치료하지 않고 잠들면 다음 날 아침 괴물이 될 수도 있다.',
          true: false,
          src: 'sick1',
        },
        dg_pills_2: {
          text: '수면제는 대겸에게 효과가 없다. 오히려 그를 더 자극할 뿐이다.',
          true: false,
          src: 'sus1',
        },
      };

      // ═══════════════════════════════════════
      // GAME STATE
      // ═══════════════════════════════════════
      const G = {
        day: 1,
        time: 0,
        dayLen: 75,
        phase: 'morning',
        timer: null,
        over: false,
        paused: false,
        acCool: false,
        p: {
          id: 'player',
          name: '',
          charClass: '',
          hp: 100,
          maxhp: 100,
          hunger: 0,
          thirst: 0,
          fatigue: 0,
          sanity: 100,
          money: 500,
          rep: 50,
          sp: 0, // skill points
          skills: {
            strength: 0,
            agility: 0,
            social: 0,
            intel: 0,
            survival: 0,
            stealth: 0,
            medical: 0,
            combat: 0,
          },
          xp: {
            strength: 0,
            agility: 0,
            social: 0,
            intel: 0,
            survival: 0,
            stealth: 0,
            medical: 0,
            combat: 0,
          },
          weapon: null,
          armor: false,
          sick: false,
          injured: false,
          infected: false,
          cold: false,
          ganged: false,
          gangName: null,
          loc: 'classroom_a',
          knownInfo: [],
          inventory: [],
          hiding: false,
          killCount: 0,
          specialCooldown: 0,
          specialUsesToday: 0,
          helpedCount: 0,
          robbedCount: 0,
          daysSurvived: 0,
        },
        world: {
          survivors: 100,
          totalFood: 150,
          order: 65,
          temp: -2,
          deaths: 0,
          dgStage: 0,
          dgKilled: 0,
          chaos: false,
          chaosLevel: 0,
          kitchenLocked: false,
          officeLocked: false,
          evsDone: [],
          randCooldown: 0,
          factions: {
            gangsters: {
              power: 70,
              members: ['gangster1', 'gangster2', 'gangster3'],
              friendly: false,
            },
            honor: {
              power: 45,
              members: ['honor1', 'honor2', 'honor3'],
              friendly: true,
            },
            teacher_good: {
              power: 55,
              members: ['teacher_good1', 'teacher_good2', 'principal'],
              friendly: true,
            },
            council: {
              power: 50,
              members: ['council1', 'council2'],
              friendly: true,
            },
          },
        },
        people: [],
        log: [],
        selectedPerson: null,
      };

      // ═══════════════════════════════════════
      // UTILS
      // ═══════════════════════════════════════
      function r(n) {
        return Math.floor(Math.random() * n);
      }
      function rr() {
        return Math.random();
      }
      function clamp(v, mn, mx) {
        return Math.max(mn, Math.min(mx, v));
      }
      function gp(id) {
        return G.people.find((p) => p.id === id);
      }
      function alive(id) {
        const p = gp(id);
        return p && p.alive;
      }
      function skillBonus(sk, mul = 1) {
        return G.p.skills[sk] * mul;
      }

      // Affinity helpers
      function getAff(personId) {
        const p = gp(personId);
        return p ? p.affinity : 0;
      }
      function changeAff(personId, delta) {
        const p = gp(personId);
        if (!p || !p.alive) return;
        // social skill boosts positive affinity gain
        if (delta > 0)
          delta = Math.ceil(delta * (1 + skillBonus('social', 0.2)));
        p.affinity = clamp(p.affinity + delta, -100, 100);
        updatePeopleTab();
      }
      function affLabel(v) {
        if (v >= 70) return { txt: '연인', cls: 'lover' };
        if (v >= 40) return { txt: '절친', cls: 'friend' };
        if (v >= 20) return { txt: '우호', cls: 'friend' };
        if (v >= -10) return { txt: '중립', cls: 'neutral' };
        if (v >= -40) return { txt: '경계', cls: 'enemy' };
        return { txt: '적대', cls: 'enemy' };
      }

      // Info system
      function learnInfo(id) {
        if (G.p.knownInfo.includes(id)) return false;
        G.p.knownInfo.push(id);
        const info = INFO_DB[id];
        if (!info) return false;
        const verified = G.p.skills.intel >= 2; // 지력 2 이상이면 거짓말 탐지
        const marker =
          verified && !info.true
            ? ' [의심스러움]'
            : !verified && !info.true
              ? ''
              : ' [확인됨]';
        log(`[정보] ${info.text}${marker}`, 'in');
        if (verified && !info.true) {
          log(`> 지력이 높아 이 정보가 거짓일 가능성을 감지했다.`, 'sy');
        }
        return true;
      }

      // ═══════════════════════════════════════
      // INVENTORY
      // ═══════════════════════════════════════
      function addItem(id, qty = 1) {
        const ex = G.p.inventory.find((i) => i.id === id);
        if (ex) ex.qty += qty;
        else G.p.inventory.push({ id, qty });
        updateInv();
      }
      function removeItem(id, qty = 1) {
        const idx = G.p.inventory.findIndex((i) => i.id === id);
        if (idx < 0) return false;
        G.p.inventory[idx].qty -= qty;
        if (G.p.inventory[idx].qty <= 0) G.p.inventory.splice(idx, 1);
        updateInv();
        return true;
      }
      function hasItem(id) {
        return G.p.inventory.some((i) => i.id === id && i.qty > 0);
      }
      function itemQty(id) {
        const i = G.p.inventory.find((x) => x.id === id);
        return i ? i.qty : 0;
      }
      // NPC inventory helpers
      function npcHasItem(per, id) {
        return per.inventory && per.inventory.includes(id);
      }
      function npcItemCount(per, id) {
        if (!per.inventory) return 0;
        return per.inventory.filter((x) => x === id).length;
      }
      function npcRemoveItem(per, id) {
        if (!per.inventory) return false;
        const idx = per.inventory.indexOf(id);
        if (idx < 0) return false;
        per.inventory.splice(idx, 1);
        return true;
      }
      function npcAddItem(per, id) {
        if (!per.inventory) per.inventory = [];
        per.inventory.push(id);
      }
      // P2P price calculator based on affinity
      function tradePrice(basePrice, per) {
        const aff = per.affinity;
        const socialBonus = skillBonus('social', 0.05);
        let mult;
        if (aff >= 70) mult = 0.1;
        else if (aff >= 40) mult = 0.3;
        else if (aff >= 20) mult = 0.7;
        else if (aff >= -10) mult = 1.0;
        else if (aff >= -40) mult = 2.0;
        else mult = -1; // refuses
        if (mult < 0) return -1;
        let finalPrice = Math.max(
          1,
          Math.floor(basePrice * mult * (1 - socialBonus)),
        );
        if (G.p.charClass === 'mincheol')
          finalPrice = Math.max(1, Math.floor(finalPrice * 0.8));
        return finalPrice;
      }

      function updateGlobalResources() {
        let totalFood = 0;
        let totalWater = 0;

        // Sum player resources
        totalFood += itemQty('food_ration') + itemQty('canned_food') * 2;
        totalWater += itemQty('water_bottle');

        // Sum NPC resources
        G.people.forEach((p) => {
          if (p.alive) {
            (p.inventory || []).forEach((item) => {
              if (item === 'food_ration') totalFood++;
              if (item === 'canned_food') totalFood += 2;
              if (item === 'water_bottle') totalWater++;
            });
          }
        });

        G.world.totalFood = totalFood;
        G.world.totalWater = totalWater;
      }

      // ═══════════════════════════════════════
      // LOG
      // ═══════════════════════════════════════
      const LP = document.getElementById('logpanel');
      let dayMinutes = 0;
      function log(txt, cls = 'na') {
        const e = document.createElement('div');
        e.className = 'lentry';
        // Add colored border class based on log type
        const borderTypes = ['ev', 'da', 'ok', 'in', 'dg', 'dgt'];
        if (borderTypes.includes(cls)) e.classList.add('t-' + cls);
        const ts = document.createElement('div');
        ts.className = 'lts';
        const m = Math.floor(G.time / 60),
          s = G.time % 60;
        ts.textContent = `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        const t = document.createElement('div');
        t.className = 'ltxt ' + cls;
        t.textContent = txt;
        e.appendChild(ts);
        e.appendChild(t);
        LP.appendChild(e);
        LP.scrollTop = LP.scrollHeight;
        // Screen shake on damage/danger entries
        if (cls === 'da' || cls === 'dg') {
          document.body.classList.add('shake');
          setTimeout(() => document.body.classList.remove('shake'), 300);
        }
      }
      function logSep(label) {
        const e = document.createElement('div');
        e.className = 'lentry';
        const t = document.createElement('div');
        t.className = 'ltxt sep';
        t.textContent =
          '─'.repeat(8) + '  DAY ' + G.day + ' ' + label + '  ' + '─'.repeat(8);
        e.appendChild(t);
        LP.appendChild(e);
        LP.scrollTop = LP.scrollHeight;
      }
      function logGap() {
        const e = document.createElement('div');
        e.className = 'lentry gap';
        LP.appendChild(e);
      }

      // ═══════════════════════════════════════
      // TOAST
      // ═══════════════════════════════════════
      let tt;
      function toast(msg, type = '') {
        const el = document.getElementById('toast');
        el.textContent = msg;
        el.className = 'show' + (type ? ' ' + type : '');
        clearTimeout(tt);
        tt = setTimeout(() => (el.className = ''), 2500);
      }

      // ═══════════════════════════════════════
      // UI UPDATE
      // ═══════════════════════════════════════
      function sc(val, lo, hi) {
        if (val <= lo) return 'da';
        if (val <= hi) return 'wa';
        return 'ok';
      }
      function sci(val, hi, mid) {
        if (val >= hi) return 'da';
        if (val >= mid) return 'wa';
        return 'ok';
      }
      function updateStats() {
        const p = G.p;
        const setV = (id, v, cls) => {
          const e = document.getElementById(id);
          if (e) {
            e.textContent = v;
            e.className = 'hval ' + cls;
          }
        };
        const setB = (id, pct, col) => {
          const e = document.getElementById(id);
          if (e) {
            e.style.width = clamp(pct, 0, 100) + '%';
            if (col) e.style.background = col;
          }
        };
        setV('shp', p.hp, sc(p.hp, 20, 50));
        setB('bhp', p.hp, '');
        setV('shu', p.hunger, sci(p.hunger, 80, 50));
        setB('bhu', p.hunger);
        setV('sth', p.thirst, sci(p.thirst, 80, 50));
        setB('bth', p.thirst);
        setV('sfa', p.fatigue, sci(p.fatigue, 80, 50));
        setB('bfa', p.fatigue);
        setV('ssa', p.sanity, sc(p.sanity, 20, 50));
        setB('bsa', p.sanity, '');
        setV(
          'sfo',
          itemQty('food_ration') + itemQty('canned_food'),
          sc(itemQty('food_ration'), 0, 1),
        );
        setV('swa', itemQty('water_bottle'), sc(itemQty('water_bottle'), 0, 1));
        setV('smo', p.money, sc(p.money, 50, 200));
        setV('sre', p.rep, sc(p.rep, 10, 30));
        setV('ssp', p.sp, 'pu');
        document.getElementById('daydis').textContent = 'DAY ' + G.day;
        const ph = { morning: '아침', afternoon: '오후', night: '밤' };
        document.getElementById('phasedis').textContent =
          ph[G.phase] || G.phase;
        const pct = (G.time / G.dayLen) * 100;
        document.getElementById('timerfill').style.width = pct + '%';
        document.getElementById('timerfill').style.background =
          G.phase === 'night' ? '#1a1a3a' : p.hp < 30 ? '#6a1818' : '#1a4a2a';
      }
      function updateWorld() {
        const w = G.world;
        const sv = G.people.filter((p) => p.alive).length;
        const sd = (id, v, cls) => {
          const e = document.getElementById(id);
          if (e) {
            e.textContent = v;
            e.className = 'wval ' + (cls || '');
          }
        };
        sd('wsurv', sv + '명', sv < 30 ? 'crit' : sv < 60 ? 'bad' : '');
        sd(
          'wfood',
          w.totalFood + '개',
          w.totalFood < 100 ? 'crit' : w.totalFood < 300 ? 'bad' : '',
        );
        const dl = sv > 0 ? Math.floor(w.totalFood / (sv * 0.65)) : 0;
        sd('wdays', '약 ' + dl + '일', dl < 2 ? 'crit' : dl < 4 ? 'bad' : '');
        const ot =
          w.order < 20
            ? '붕괴'
            : w.order < 40
              ? '혼란'
              : w.order < 60
                ? '불안'
                : w.order < 80
                  ? '긴장'
                  : '안정';
        sd('worder', ot, w.order < 30 ? 'crit' : w.order < 50 ? 'bad' : 'gd');
        sd(
          'wtemp',
          w.temp + '°C',
          w.temp < -8 ? 'crit' : w.temp < -4 ? 'bad' : '',
        );
        const dgT = [
          '침묵',
          '소문',
          '접촉',
          '교장사망',
          '교사사망',
          '배급중단',
          '사냥중',
          '최후',
        ];
        sd(
          'wdg',
          dgT[Math.min(w.dgStage, 7)],
          w.dgStage >= 3 ? 'crit' : w.dgStage >= 1 ? 'bad' : '',
        );
        // location
        const loc = ROOMS[G.p.loc];
        if (loc) document.getElementById('curloc').textContent = loc.name;
        // gang
        const gi = document.getElementById('ganginfo');
        if (G.p.ganged) gi.textContent = G.p.gangName;
        else gi.textContent = '없음';
        // statuses
        const sts = [];
        if (G.p.sick) sts.push('병');
        if (G.p.injured) sts.push('부상');
        if (G.p.infected) sts.push('감염');
        if (G.p.cold) sts.push('저체온');
        document.getElementById('statuses').textContent = sts.length
          ? sts.join(', ')
          : '없음';
      }
      function updateInv() {
        const grid = document.getElementById('invgrid');
        if (!grid) return;
        grid.innerHTML = '';
        if (!G.p.inventory.length) {
          grid.innerHTML =
            '<span style="font-size:10px;color:var(--t4)">없음</span>';
          return;
        }
        G.p.inventory.forEach((it) => {
          const def = ITEMS[it.id];
          const s = document.createElement('span');
          s.style.cssText =
            'font-size:10px;color:var(--t2);background:var(--bg3);border:1px solid var(--b1);padding:2px 6px;cursor:pointer;';
          s.textContent =
            (def ? def.icon + def.name : it.id) +
            (it.qty > 1 ? '×' + it.qty : '');
          s.title = def ? def.desc : '';
          s.onclick = () => useItem(it.id);
          grid.appendChild(s);
        });
      }
      function updatePeopleTab() {
        const list = document.getElementById('peoplelist');
        if (!list) return;
        const alive = G.people.filter((p) => p.alive && p.id !== 'daegyeom');
        const dead = G.people.filter((p) => !p.alive && p.id !== 'daegyeom');
        document.getElementById('pplcount').textContent =
          `(생존 ${alive.length}명)`;
        list.innerHTML = '';
        // Show named NPCs first
        const named = alive
          .filter((p) => !p.id.startsWith('anon'))
          .concat(dead.filter((p) => !p.id.startsWith('anon')));
        const anon = alive.filter((p) => p.id.startsWith('anon'));
        [...named, ...anon.slice(0, 20)].forEach((per) => {
          const d = document.createElement('div');
          d.className = 'pentry';
          const al = affLabel(per.affinity);
          d.innerHTML = `<div><span class="pname${per.alive ? '' : ' dead'}">${per.name}</span><span class="prel ${al.cls}" style="float:right">${al.txt}</span></div><div class="pinfo">${per.group} · ${ROOMS[per.loc] ? ROOMS[per.loc].name : '?'}</div>`;
          d.onclick = () => showPersonDetail(per.id);
          list.appendChild(d);
        });
        if (anon.length > 20) {
          const more = document.createElement('div');
          more.style.cssText =
            'font-size:10px;color:var(--t4);padding:4px 6px;';
          more.textContent = `... 외 익명 ${anon.length - 20}명`;
          list.appendChild(more);
        }
      }
      function updateMap() {
        const mc = document.getElementById('mapcontainer');
        if (!mc) return;
        mc.innerHTML = '';
        const order = [
          'classroom_a',
          'classroom_b',
          'hallway1',
          'hallway2',
          'office',
          'library',
          'cafeteria',
          'gym',
          'rooftop',
          'warehouse',
          'science_lab',
          'bathroom',
        ];
        // Sort: current first, then connected, then others
        const connected = ROOM_CONNECTIONS[G.p.loc] || [];
        const sorted = order.sort((a, b) => {
          if (a === G.p.loc) return -1;
          if (b === G.p.loc) return 1;
          const ac = connected.includes(a);
          const bc = connected.includes(b);
          if (ac && !bc) return -1;
          if (!ac && bc) return 1;
          return 0;
        });
        sorted.forEach((rid) => {
          const room = ROOMS[rid];
          if (!room) return;
          const isCurrent = G.p.loc === rid;
          const isConn = connected.includes(rid);
          const hasDg = G.world.dgStage >= 6 && rid !== 'unknown';
          const pplHere = G.people.filter((p) => p.alive && p.loc === rid);
          const d = document.createElement('div');
          let cls = 'maproom';
          if (isCurrent) cls += ' current';
          else if (isConn) cls += ' connected';
          if (room.dangerLevel >= 3 || (hasDg && r(3) === 0)) cls += ' danger';
          d.className = cls;
          // Build people dots
          let dotsHtml = '';
          if (pplHere.length > 0) {
            const shown = pplHere.slice(0, 8);
            dotsHtml =
              '<span class="mroom-dots">' +
              shown
                .map((p) => {
                  const isFriendly =
                    p.affinity >= 10 ||
                    p.role === 'honor' ||
                    p.role === 'council';
                  const isHostile = p.role === 'gangster' || p.affinity < -20;
                  return `<span class="${isHostile ? 'hostile' : isFriendly ? 'friendly' : ''}"></span>`;
                })
                .join('') +
              (pplHere.length > 8
                ? `<span>+${pplHere.length - 8}</span>`
                : '') +
              '</span>';
          }
          const badge = room.safe ? 'safe' : 'unsafe';
          const arrow = isCurrent ? '▶' : isConn ? '→' : '·';
          d.innerHTML = `<div class="mroom-name ${isCurrent ? 'current' : ''}">${arrow} ${room.name}${dotsHtml}</div>
          <div class="mroom-info">${room.desc}</div>
          <div class="mroom-people">인원: ${pplHere.length}명 · 위험도: ${'▮'.repeat(room.dangerLevel)}${'▯'.repeat(4 - room.dangerLevel)}</div>
          <span class="mroom-badge ${badge}">${room.safe ? '안전' : '위험'}</span>`;
          if (isConn && !isCurrent) {
            d.style.cursor = 'pointer';
            d.onclick = () => moveToRoom(rid);
          } else if (!isCurrent) {
            d.style.opacity = '0.4';
          }
          mc.appendChild(d);
        });
      }
      function updateSkillTab() {
        const st = document.getElementById('skilltree');
        if (!st) return;
        document.getElementById('spcount').textContent = G.p.sp;
        st.innerHTML = '';
        Object.entries(SKILL_DEFS).forEach(([sk, def]) => {
          const lv = G.p.skills[sk];
          const xp = G.p.xp[sk];
          const nextXp = (lv + 1) * 30;
          const d = document.createElement('div');
          d.className = 'skill-row';
          d.innerHTML = `<div style="font-size:11px;width:60px;color:var(--t2)">${def.icon} ${def.name}</div>
          <div class="skill-bar"><div class="skill-fill" style="width:${lv >= def.maxlv ? 100 : Math.floor((xp / nextXp) * 100)}%"></div></div>
          <div class="skill-lvl" style="width:40px">Lv${lv}/${def.maxlv}</div>
          <button class="skill-up" onclick="upgradeSkill('${sk}')" ${G.p.sp <= 0 || lv >= def.maxlv ? 'disabled' : ''}>↑</button>`;
          d.title = def.desc;
          st.appendChild(d);
        });
      }
      function gainXp(sk, amt) {
        G.p.xp[sk] = (G.p.xp[sk] || 0) + amt;
        const def = SKILL_DEFS[sk];
        const nextXp = (G.p.skills[sk] + 1) * 30;
        if (G.p.xp[sk] >= nextXp && G.p.skills[sk] < def.maxlv) {
          G.p.xp[sk] -= nextXp;
          G.p.sp++;
          toast(`SP +1 획득! (${def.name} XP)`, 'win');
          showLvFlash(`SP +1`);
          updateSkillTab();
        }
      }
      function upgradeSkill(sk) {
        if (G.p.sp <= 0 || G.p.skills[sk] >= SKILL_DEFS[sk].maxlv) return;
        G.p.sp--;
        G.p.skills[sk]++;
        const def = SKILL_DEFS[sk];
        // Apply bonuses
        if (sk === 'strength') {
          G.p.maxhp = Math.min(200, G.p.maxhp + 15);
          G.p.hp = Math.min(G.p.maxhp, G.p.hp + 15);
        }
        log(`[스킬] ${def.name} Lv${G.p.skills[sk]} 달성. ${def.desc}`, 'ok');
        showLvFlash(`${def.icon}${def.name} Lv${G.p.skills[sk]}`);
        updateSkillTab();
        updateStats();
      }
      function showLvFlash(msg) {
        const d = document.createElement('div');
        d.className = 'lvlflash';
        d.textContent = msg;
        document.body.appendChild(d);
        setTimeout(() => d.remove(), 2500);
      }

      function fullUpdate() {
        updateStats();
        updateWorld();
        updateInv();
        updatePeopleTab();
        updateMap();
        updateSkillTab();
      }

      // ═══════════════════════════════════════
      // TAB SWITCHING
      // ═══════════════════════════════════════
      function switchTab(id) {
        document
          .querySelectorAll('.tab')
          .forEach((t) => t.classList.remove('active'));
        document
          .querySelectorAll('.tabcontent')
          .forEach((t) => t.classList.remove('active'));
        document.getElementById('tab-' + id).classList.add('active');
        event.target.classList.add('active');
        if (id === 'map') updateMap();
        if (id === 'skill') updateSkillTab();
        if (id === 'people') updatePeopleTab();
      }

      // ═══════════════════════════════════════
      // MODAL
      // ═══════════════════════════════════════
      const modalQueue = [];
      function showModal(
        title,
        body,
        choices,
        isDg = false,
        pretag = '// 이벤트',
      ) {
        const bg = document.getElementById('modalbg');
        // Queue if modal already visible
        if (!bg.classList.contains('h')) {
          modalQueue.push({ title, body, choices, isDg, pretag });
          return;
        }
        G.paused = true;
        const box = document.getElementById('mbox');
        document.getElementById('mpretag').textContent = isDg
          ? '// 박대겸'
          : pretag;
        const mt = document.getElementById('mtitle');
        mt.textContent = title;
        mt.className = 'mtitle' + (isDg ? ' dg' : '');
        const mb = document.getElementById('mbody');
        mb.textContent = body;
        mb.className = 'mbody' + (isDg ? ' dg' : '');
        box.className = 'mbox' + (isDg ? ' dgbox' : '');
        const mc = document.getElementById('mchoices');
        mc.innerHTML = '';
        choices.forEach((c, i) => {
          const btn = document.createElement('button');
          btn.className = 'mchoice' + (isDg || c.dg ? ' dg' : '');
          btn.innerHTML = `<div>[${String.fromCharCode(65 + i)}] ${c.label}</div>${c.sub ? `<div class="msub">${c.sub}</div>` : ''}`;
          btn.disabled = c.disabled || false;
          btn.onclick = () => {
            if (btn.disabled) return;
            bg.classList.add('h');
            G.paused = false;
            c.action();
            checkDeath();
            fullUpdate();
            // Process queue
            if (modalQueue.length > 0) {
              const next = modalQueue.shift();
              setTimeout(
                () =>
                  showModal(
                    next.title,
                    next.body,
                    next.choices,
                    next.isDg,
                    next.pretag,
                  ),
                200,
              );
            }
          };
          mc.appendChild(btn);
        });
        bg.classList.remove('h');
      }
      function closeModal() {
        document.getElementById('modalbg').classList.add('h');
        G.paused = false;
        if (modalQueue.length > 0) {
          const next = modalQueue.shift();
          setTimeout(
            () =>
              showModal(
                next.title,
                next.body,
                next.choices,
                next.isDg,
                next.pretag,
              ),
            200,
          );
        }
      }

      // ═══════════════════════════════════════
      // PERSON DETAIL MODAL
      // ═══════════════════════════════════════
      function showPersonDetail(pid) {
        const per = gp(pid);
        if (!per) return;
        const al = affLabel(per.affinity);
        const infoList = per.info.filter((i) => G.p.knownInfo.includes(i));
        const canLearn = per.info.filter((i) => !G.p.knownInfo.includes(i));
        const choices = [];
        if (per.alive && per.id !== 'daegyeom') {
          choices.push({
            label: '대화 시도',
            sub: `호감도 ${per.affinity} · ${al.txt}`,
            action: () => doTalkTo(pid),
          });
          if (canLearn.length > 0 && per.trustworthy && per.affinity >= 10) {
            choices.push({
              label: '정보 물어보기',
              sub: `정보 ${canLearn.length}개 보유 중`,
              action: () => {
                const info = canLearn[0];
                learnInfo(info);
                gainXp('intel', 8);
                changeAff(pid, -2);
              },
            });
          } else if (
            canLearn.length > 0 &&
            !per.trustworthy &&
            per.affinity >= 30
          ) {
            choices.push({
              label: '정보 물어보기 (친밀도 이용)',
              sub: '호감도 30 이상 필요',
              action: () => {
                learnInfo(canLearn[0]);
                gainXp('intel', 10);
              },
            });
          }
          if (per.affinity >= 20) {
            choices.push({
              label: '동맹 제안',
              sub: '호감도 20 이상',
              action: () => {
                if (per.affinity >= 20) {
                  log(`${per.name}과(와) 동맹을 맺었다.`, 'ok');
                  per.affinity = Math.min(100, per.affinity + 10);
                } else toast('호감도가 부족하다', 'err');
              },
            });
          }
          if (per.loveInt && per.affinity >= 50) {
            choices.push({
              label: '💕 고백',
              sub: '호감도 50 이상',
              action: () => doConfess(pid),
            });
          }
          if (npcItemCount(per, 'food_ration') > 0 && per.affinity < 0) {
            choices.push({
              label: '식량으로 회유',
              sub: `식량 1개 지출`,
              action: () => {
                if (!hasItem('food_ration')) {
                  toast('식량 없음', 'err');
                  return;
                }
                removeItem('food_ration');
                G.world.totalFood--;
                changeAff(pid, 15);
                log(`${per.name}에게 식량 1개를 줬다. 호감도 상승.`, 'ok');
              },
            });
          }
          if (
            G.p.money >= 100 &&
            per.trustworthy === false &&
            per.affinity < 0
          ) {
            choices.push({
              label: '뇌물 (100원)',
              sub: '비신뢰 NPC 대상',
              action: () => {
                G.p.money -= 100;
                changeAff(pid, 20);
                log(`${per.name}에게 100원을 줬다.`, 'na');
                gainXp('social', 5);
              },
            });
          }
          // ATTACK NPC
          choices.push({
            label: '🔴 공격하기',
            sub: '치명적 결과가 발생할 수 있다.',
            dg: true,
            action: () => {
              const weapBonus =
                G.p.weapon === 'bat'
                  ? 15
                  : G.p.weapon === 'knife'
                    ? 20
                    : G.p.weapon === 'pipe'
                      ? 12
                      : 0;
              const chance = 0.3 + skillBonus('combat', 0.2) + weapBonus / 100;
              if (rr() < chance) {
                per.alive = false;
                G.world.deaths++;
                G.p.killCount++;
                G.p.rep = clamp(G.p.rep - 25, 0, 100);
                G.p.sanity = clamp(G.p.sanity - 20, 0, 100);
                G.world.order = clamp(G.world.order - 5, 0, 100);
                log(
                  `${per.name}을(를) 살해했다. 피가 손에 뱄다. (평판-25, 광기+)`,
                  'da',
                );
                if (per.inventory && per.inventory.length > 0) {
                  log(
                    `${per.name}의 유류품 ${per.inventory.length}개를 챙겼다.`,
                    'ok',
                  );
                  per.inventory.forEach((i) => addItem(i));
                }
                checkEnding();
              } else {
                const dmg = r(20) + 10;
                G.p.hp = Math.max(0, G.p.hp - dmg);
                changeAff(pid, -50);
                log(`${per.name}의 반격에 당했다! HP -${dmg}`, 'da');
              }
            },
          });
        }
        choices.push({ label: '닫기', sub: '', action: () => {} });
        const locName = ROOMS[per.loc] ? ROOMS[per.loc].name : '알 수 없음';
        const bodyTxt = `${per.desc}\n\n소속: ${per.group}\n위치: ${locName}\n호감도: ${per.affinity} (${al.txt})\n신뢰도: ${per.trustworthy ? '높음' : '낮음'}\n알려진 정보: ${infoList.length}개`;
        showModal(per.name, bodyTxt, choices, false, `// 인물 상세`);
      }

      function doTalkTo(pid) {
        const per = gp(pid);
        if (!per || !per.alive) return;
        const diff = G.p.loc === per.loc;
        if (!diff) {
          toast(`${per.name}은 다른 구역에 있다`, 'err');
          return;
        }
        // Social check
        const success = rr() < 0.5 + skillBonus('social', 0.1);
        if (success) {
          const delta = Math.floor(5 + skillBonus('social', 2));
          changeAff(pid, delta);
          gainXp('social', 6);
          const lines = [
            `${per.name}과(와) 이야기했다. 조금 가까워진 것 같다.`,
            `${per.name}이 힘겹게 웃었다. 이런 상황에서도 사람과 이야기하는 게 도움이 된다.`,
            `"고마워." ${per.name}이 조용히 말했다.`,
          ];
          log(lines[r(lines.length)], 'ok');
        } else {
          changeAff(pid, -3);
          log(`${per.name}은 지금 대화하고 싶지 않은 것 같다.`, 'sy');
        }
        G.p.fatigue = clamp(G.p.fatigue + 3, 0, 100);
      }

      function doConfess(pid) {
        const per = gp(pid);
        if (!per) return;
        if (per.affinity < 50) {
          toast('호감도가 부족하다', 'err');
          return;
        }
        const accept = rr() < per.affinity / 100;
        if (accept) {
          per.affinity = Math.min(100, per.affinity + 30);
          G.p.sanity = Math.min(100, G.p.sanity + 15);
          log(
            `${per.name}이 고개를 끄덕였다. 이런 상황에서도 마음이 생겼다.`,
            'ok',
          );
          log(`[연애] ${per.name}과(와) 연인 관계가 됐다. 심리 +15`, 'ok');
        } else {
          changeAff(pid, -10);
          G.p.sanity = Math.max(0, G.p.sanity - 5);
          log(`${per.name}이 조용히 고개를 저었다.`, 'na');
        }
      }

      // ═══════════════════════════════════════
      // MOVEMENT
      // ═══════════════════════════════════════
      function moveToRoom(rid) {
        if (
          !ROOM_CONNECTIONS[G.p.loc] ||
          !ROOM_CONNECTIONS[G.p.loc].includes(rid)
        ) {
          toast('인접한 구역이 아니다', 'err');
          return;
        }
        const room = ROOMS[rid];
        G.p.loc = rid;
        G.p.fatigue = clamp(G.p.fatigue + 5, 0, 100);
        gainXp('agility', 2);
        log(`→ [${room.name}]으로 이동했다.`, 'sy');
        // Random encounter on move
        if (rr() < 0.25 && room.dangerLevel >= 2) {
          triggerMoveEncounter(rid);
        }
        // NPC movement
        if (r(3) === 0) {
          const movable = G.people.filter(
            (p) => p.alive && !p.id.startsWith('anon') && p.id !== 'daegyeom',
          );
          if (movable.length) {
            const npc = movable[r(movable.length)];
            const conns = ROOM_CONNECTIONS[npc.loc];
            if (conns && conns.length) npc.loc = conns[r(conns.length)];
          }
        }
        fullUpdate();
      }

      function triggerMoveEncounter(rid) {
        const room = ROOMS[rid];
        const encs = [
          () => {
            const dmg = r(10) + 5;
            G.p.hp = Math.max(0, G.p.hp - dmg);
            log(`[이동 중] 누군가 갑자기 달려들었다. HP -${dmg}`, 'da');
          },
          () => {
            const stolen = Math.min(G.p.money, r(80) + 20);
            G.p.money -= stolen;
            log(`[이동 중] 이동하다 ${stolen}원을 소매치기 당했다.`, 'da');
          },
          () => {
            const food = r(2) + 1;
            G.addItem('food_ration', food);
            G.world.totalFood += food;
            log(`[이동 중] 복도에서 떨어진 식량 ${food}개를 발견했다.`, 'ok');
          },
        ];
        encs[r(encs.length)]();
      }

      // ═══════════════════════════════════════
      // ACTIONS
      // ═══════════════════════════════════════
      function doAction(a) {
        if (G.over || G.paused) {
          if (G.paused) toast('지금 행동 불가', 'err');
          return;
        }
        if (G.acCool) {
          toast('잠시 후 시도', 'err');
          return;
        }
        G.acCool = true;
        setTimeout(() => (G.acCool = false), 500);
        const p = G.p;
        // Block actions while hiding (except hide toggle)
        if (p.hiding && a !== 'hide') {
          toast('숨어있는 중에는 행동할 수 없다', 'err');
          log('숨어있다. 먼저 나와야 한다. [Z]', 'sy');
          return;
        }
        switch (a) {
          case 'eat': {
            const hasCanned = hasItem('canned_food');
            const hasRation = hasItem('food_ration');
            if (!hasCanned && !hasRation) {
              toast('식량 없음', 'err');
              log('먹을 것이 없다. 위가 뒤틀린다.', 'da');
              break;
            }
            // Prefer canned_food if available, otherwise ration
            if (hasCanned) {
              removeItem('canned_food');
              p.hunger = clamp(p.hunger - 60, 0, 100);
              p.hp = clamp(p.hp + (p.sick ? 4 : 12), 0, p.maxhp);
              gainXp('survival', 3);
              log('통조림을 먹었다. HP +' + (p.sick ? 4 : 12), 'ok');
            } else {
              removeItem('food_ration');
              p.hunger = clamp(p.hunger - 50, 0, 100);
              p.hp = clamp(p.hp + (p.sick ? 2 : 8), 0, p.maxhp);
              gainXp('survival', 3);
              if (p.sick) log('먹었지만 속이 좋지 않다. HP +2', 'na');
              else log('식사했다. 잠시 안정감이 든다. HP +8', 'ok');
            }
            G.world.totalFood = Math.max(0, G.world.totalFood - 1);
            break;
          }
          case 'drink':
            if (!hasItem('water_bottle')) {
              toast('물 없음', 'err');
              log('마실 것이 없다. 입술이 갈라진다.', 'da');
              break;
            }
            removeItem('water_bottle');
            p.thirst = clamp(p.thirst - 55, 0, 100);
            p.hp = clamp(p.hp + 4, 0, p.maxhp);
            log('물을 마셨다. HP +4', 'ok');
            break;
          case 'hide':
            {
              const room = ROOMS[p.loc];
              if (p.hiding) {
                p.hiding = false;
                log('숨는 곳에서 나왔다. 다시 활동 시작.', 'ok');
                toast('활동중', '');
              } else if (!room || !room.hideSpot) {
                toast('이 구역에는 숨을 곳이 없다', 'err');
                log(
                  `[${room ? room.name : p.loc}] 여기서는 숨을 수 없다.`,
                  'da',
                );
              } else {
                p.hiding = true;
                const chance = Math.floor(room.hideChance * 100);
                log(
                  `숨었다. 은폐 확률: ${chance}% (은신 스킬 보너스 적용됨)`,
                  'ok',
                );
                toast('숨어있음 🙈', '');
              }
              break;
            }
            break;
          case 'rest': {
            if (p.fatigue < 10) {
              toast('피곤하지 않다', '');
              break;
            }
            const restAmt = 25 + skillBonus('survival', 3);
            p.fatigue = clamp(p.fatigue - restAmt, 0, 100);
            p.hp = clamp(p.hp + 5, 0, p.maxhp);
            // Theft during rest
            if (
              rr() < 0.15 - skillBonus('stealth', 0.02) &&
              G.world.order < 55 &&
              !hasItem('lock')
            ) {
              const s = Math.min(p.money, r(80) + 20);
              p.money -= s;
              if (s) log(`쉬는 사이 ${s}원이 없어졌다.`, 'da');
              else log('쉬는 동안 누가 뒤적였지만 가져갈 게 없었다.', 'sy');
            } else {
              const msgs = [
                '눈을 잠깐 감았다. 꿈에서도 학교였다.',
                '복도 소음이 멀게 들렸다.',
                '잠들 수 없었지만 쉬었다.',
              ];
              log(msgs[r(msgs.length)], 'na');
            }
            gainXp('survival', 3);
            break;
          }
          case 'medic': {
            if (hasItem('first_aid')) {
              removeItem('first_aid');
              const heal = 25 + skillBonus('medical', 8);
              p.hp = clamp(p.hp + heal, 0, p.maxhp);
              p.injured = false;
              log(`구급키트 사용. HP +${heal}`, 'ok');
              gainXp('medical', 15);
            } else if (hasItem('antibiotics') && (p.sick || p.infected)) {
              removeItem('antibiotics');
              p.sick = false;
              p.infected = false;
              p.hp = clamp(p.hp + 15, 0, p.maxhp);
              log('항생제 투여. 감염/병 치료. HP +15', 'ok');
              gainXp('medical', 10);
            } else {
              toast('치료 아이템 없음', 'err');
              log('치료 아이템이 없다.', 'sy');
            }
            break;
          }
          case 'explore':
            doExplore();
            break;
          case 'move':
            switchTab('map');
            toast('지도에서 이동할 구역 클릭', '');
            break;
          case 'scout':
            doScout();
            break;
          case 'talk':
            doTalkAction();
            break;
          case 'trade':
            doTradeModal();
            break;
          case 'guard':
            doGuard();
            break;
          case 'help':
            doHelp();
            break;
          case 'intel':
            doIntel();
            break;
          case 'rob':
            doRobModal();
            break;
          case 'gang':
            doGangModal();
            break;
          case 'craft':
            doCraftModal();
            break;
          case 'charskill':
            doCharSkill();
            break;
          default:
            toast('알 수 없는 행동', 'err');
        }
        checkDeath();
        fullUpdate();
      }

      // ── EXPLORE ──
      function doExplore() {
        const p = G.p;
        const room = ROOMS[p.loc];
        if (!room || !room.searchable) {
          toast('탐색 불가 구역', 'err');
          return;
        }
        p.fatigue = clamp(p.fatigue + 8, 0, 100);
        gainXp('survival', 5);
        if (p.skills.agility >= 2) gainXp('agility', 2);
        const lk = rr();
        const sBonus = skillBonus('survival', 0.05);
        if (lk < 0.2 + sBonus && room.food > 0) {
          const f = r(2) + 1;
          addItem('food_ration', f);
          G.world.totalFood += f;
          room.food = Math.max(0, room.food - f);
          log(`[${room.name}] 식량 ${f}개 발견.`, 'ok');
        } else if (lk < 0.35 + sBonus && room.items && room.items.length) {
          const item = room.items[r(room.items.length)];
          addItem(item);
          log(
            `[${room.name}] ${ITEMS[item] ? ITEMS[item].name : item}을(를) 발견했다.`,
            'ok',
          );
          room.items = room.items.filter((i) => i !== item);
        } else if (lk < 0.5) {
          const cash = r(120) + 20;
          p.money += cash;
          log(`[${room.name}] 방치된 가방에서 ${cash}원 발견.`, 'ok');
        } else if (lk < 0.65) {
          addItem('water_bottle');
          log(`[${room.name}] 수도에서 물을 받았다.`, 'ok');
        } else if (lk < 0.72 && room.dangerLevel >= 2) {
          const dmg = r(12) + 5;
          p.hp = Math.max(0, p.hp - dmg);
          p.injured = true;
          log(`[${room.name}] 탐색 중 부딪혔다. HP -${dmg}. 부상.`, 'da');
        } else if (lk < 0.78 && room.dangerLevel >= 3) {
          p.sick = true;
          log(`[${room.name}] 오염된 것을 건드렸다. 병에 걸렸다.`, 'da');
        } else if (lk < 0.85) {
          // 정보 발견
          const infoKeys = Object.keys(INFO_DB);
          const unlrn = infoKeys.filter((k) => !p.knownInfo.includes(k));
          if (unlrn.length) {
            learnInfo(unlrn[r(unlrn.length)]);
            gainXp('intel', 5);
          } else log(`[${room.name}] 특이한 점을 발견하지 못했다.`, 'sy');
        } else {
          const msgs = [
            `[${room.name}] 아무것도 없다.`,
            `[${room.name}] 이미 다 털린 것 같다.`,
            `[${room.name}] 구석에 먼지뿐이다.`,
          ];
          log(msgs[r(msgs.length)], 'sy');
        }
      }

      // ── SCOUT ──
      function doScout() {
        const p = G.p;
        p.fatigue = clamp(p.fatigue + 6, 0, 100);
        gainXp('intel', 4);
        gainXp('agility', 2);
        const rids = Object.keys(ROOMS);
        const target = rids[r(rids.length)];
        const room = ROOMS[target];
        const pplThere = G.people.filter((x) => x.alive && x.loc === target);
        log(
          `[정찰] ${room.name}: 인원 ${pplThere.length}명, 위험도 ${room.dangerLevel}/4, 식량 추정 ${room.food}개`,
          'in',
        );
        if (pplThere.length && rr() < 0.4) {
          const npc = pplThere[r(pplThere.length)];
          log(`> ${npc.name}이(가) 그곳에 있다. (${npc.group})`, 'in');
        }
        if (G.world.dgStage >= 6 && rr() < 0.3) {
          log(`[경고] 대겸의 흔적이 근처에서 발견됐다.`, 'dg');
        }
      }

      // ── TALK ──
      function doTalkAction() {
        const here = G.people.filter(
          (p) =>
            p.alive &&
            p.loc === G.p.loc &&
            p.id !== 'daegyeom' &&
            !p.id.startsWith('anon'),
        );
        if (!here.length) {
          log('이 구역에 대화할 사람이 없다.', 'sy');
          return;
        }
        const choices = here.slice(0, 5).map((per) => ({
          label: per.name + ' (' + per.group + ')',
          sub: `호감도 ${per.affinity} · ${affLabel(per.affinity).txt}`,
          action: () => showPersonDetail(per.id),
        }));
        choices.push({ label: '그냥 간다', sub: '', action: () => {} });
        showModal(
          '// 대화 상대 선택',
          `이 구역(${ROOMS[G.p.loc].name})에 있는 사람들:`,
          choices,
        );
      }

      // ── GUARD ──
      function doGuard() {
        const p = G.p;
        p.fatigue = clamp(p.fatigue + 18, 0, 100);
        const pay = 60 + skillBonus('combat', 10);
        p.money += pay;
        G.world.order = clamp(G.world.order + 3, 0, 100);
        gainXp('combat', 4);
        gainXp('strength', 3);
        if (rr() < 0.25) {
          p.rep = clamp(p.rep + 5, 0, 100);
          log(`경계 임무 완료. ${pay}원 수령. 누군가 위협을 막았다.`, 'ok');
        } else if (rr() < 0.15) {
          const dmg = r(10) + 5;
          p.hp = Math.max(0, p.hp - dmg);
          p.injured = true;
          log(`경계 중 교전. HP -${dmg}. ${pay}원 수령.`, 'da');
        } else {
          log(`경계 임무 완료. ${pay}원 수령.`, 'ok');
        }
      }

      // ── HELP ──
      function doHelp() {
        const p = G.p;
        const here = G.people.filter(
          (x) => x.alive && x.loc === p.loc && x.id !== 'daegyeom',
        );
        if (!here.length) {
          log('도울 사람이 없다.', 'sy');
          return;
        }
        const target = here[r(here.length)];
        if (hasItem('food_ration') && rr() < 0.5) {
          removeItem('food_ration');
          G.world.totalFood--;
          changeAff(target.id, 12);
          p.rep = clamp(p.rep + 4, 0, 100);
          p.sanity = clamp(p.sanity + 6, 0, 100);
          gainXp('social', 6);
          log(`${target.name}에게 식량을 나눠줬다. 호감도+12 평판+4`, 'ok');
          p.helpedCount++;
          if (p.helpedCount % 3 === 0) {
            p.sp++;
            toast('SP +1 (도움 보상)', 'win');
          }
        } else if (target.hp < 50 && p.hp > 60) {
          const heal = 10 + skillBonus('medical', 5);
          target.hp = Math.min(target.maxhp, target.hp + heal);
          changeAff(target.id, 15);
          gainXp('medical', 5);
          log(
            `${target.name}의 상처를 응급처치했다. HP +${heal} 호감도+15`,
            'ok',
          );
        } else {
          changeAff(target.id, 5);
          gainXp('social', 3);
          log(`${target.name}을(를) 달랬다. 호감도 +5`, 'ok');
        }
      }

      // ── INTEL ──
      function doIntel() {
        const p = G.p;
        // 친밀한 NPC에서 정보 수집
        const sources = G.people.filter(
          (x) =>
            x.alive &&
            x.id !== 'daegyeom' &&
            x.info.length > 0 &&
            x.affinity >= 10,
        );
        if (!sources.length) {
          log('정보를 줄 만큼 가까운 사람이 없다. 먼저 관계를 쌓아라.', 'sy');
          return;
        }
        // Sort by affinity, pick best
        sources.sort((a, b) => b.affinity - a.affinity);
        const src = sources[0];
        const unknown = src.info.filter((i) => !p.knownInfo.includes(i));
        if (!unknown.length) {
          log(`${src.name}에게 더 얻을 정보가 없다.`, 'sy');
          return;
        }
        const infoId = unknown[r(unknown.length)];
        const gotInfo = learnInfo(infoId);
        if (gotInfo) {
          gainXp('intel', 8);
          changeAff(src.id, -1);
          log(`${src.name}에게서 정보를 얻었다.`, 'in');
        }
        // Gossip check - unreliable sources may give false info
        if (!src.trustworthy && rr() < 0.3 && p.skills.intel < 2) {
          const fakeKeys = Object.keys(INFO_DB).filter(
            (k) => !INFO_DB[k].true && !p.knownInfo.includes(k),
          );
          if (fakeKeys.length) {
            learnInfo(fakeKeys[r(fakeKeys.length)]);
            log(`주의: ${src.name}은 신뢰도가 낮다. 정보를 검증하라.`, 'sy');
          }
        }
      }

      // ── TRADE MODAL ──
      function doTradeModal() {
        const p = G.p;
        const here = G.people.filter(
          (x) =>
            x.alive &&
            x.loc === p.loc &&
            x.id !== 'daegyeom' &&
            !x.id.startsWith('anon'),
        );
        if (!here.length) {
          log('이 구역에 거래할 사람이 없다.', 'sy');
          toast('거래 불가', 'err');
          return;
        }
        // Show NPC list for trading
        const choices = here.map((per) => {
          const al = affLabel(per.affinity);
          const price = tradePrice(100, per);
          const priceTag =
            price < 0 ? '거래 거부' : `가격 배율: ${Math.floor(price)}%`;
          return {
            label: `${per.name} (${per.group})`,
            sub: `${al.txt} · ${priceTag} · 소지품: ${per.inventory ? per.inventory.length : 0}개`,
            disabled: price < 0,
            action: () => showNpcTradeModal(per),
          };
        });
        choices.push({ label: '취소', sub: '', action: () => {} });
        showModal(
          '// P2P 거래',
          '이 구역에서 거래할 상대를 선택하라.',
          choices,
        );
      }
      function showNpcTradeModal(per) {
        const p = G.p;
        if (!per.inventory || per.inventory.length === 0) {
          toast(`${per.name}은(는) 가진 게 없다`, 'err');
          return;
        }
        // Deduplicate NPC inventory for display
        const counts = {};
        per.inventory.forEach((id) => {
          counts[id] = (counts[id] || 0) + 1;
        });
        const choices = [];
        Object.entries(counts).forEach(([itemId, qty]) => {
          const item = ITEMS[itemId];
          if (!item) return;
          const price = tradePrice(item.price || 100, per);
          if (price < 0) return;
          choices.push({
            label: `구매: ${item.icon} ${item.name} x${qty} — ${price}원`,
            sub: `${item.desc} | 내 돈: ${p.money}원`,
            action: () => {
              if (p.money < price) {
                toast('돈 부족', 'err');
                return;
              }
              if (!npcRemoveItem(per, itemId)) {
                toast('재고 없음', 'err');
                return;
              }
              p.money -= price;
              per.money += price;
              addItem(itemId);
              per.affinity = clamp(per.affinity + 2, -100, 100);
              const iName = item.name;
              log(`[거래] ${per.name}에게서 ${iName} 구매 (${price}원)`, 'ok');
              gainXp('social', 3);
              // Reopen trade if they still have items
              if (per.inventory.length > 0) showNpcTradeModal(per);
            },
          });
        });
        // Player selling to NPC
        if (p.inventory.length > 0) {
          choices.push({
            label: '── 내 물건 판매 ──',
            sub: '',
            disabled: true,
            action: () => {},
          });
          const added = new Set();
          p.inventory.forEach((inv) => {
            if (added.has(inv.id)) return;
            added.add(inv.id);
            const item = ITEMS[inv.id];
            if (!item) return;
            const sellPrice = Math.max(
              1,
              Math.floor(tradePrice(item.price || 100, per) * 0.5),
            );
            if (sellPrice < 0) return;
            choices.push({
              label: `판매: ${item.icon} ${item.name} x${inv.qty} — ${sellPrice}원`,
              sub: `${per.name}에게 판매`,
              action: () => {
                if (per.money < sellPrice) {
                  toast(`${per.name}의 돈 부족`, 'err');
                  return;
                }
                removeItem(inv.id);
                npcAddItem(per, inv.id);
                p.money += sellPrice;
                per.money -= sellPrice;
                per.affinity = clamp(per.affinity + 1, -100, 100);
                log(
                  `[거래] ${per.name}에게 ${item.name} 판매 (${sellPrice}원)`,
                  'ok',
                );
                gainXp('social', 2);
                if (per.inventory.length > 0 || p.inventory.length > 0)
                  showNpcTradeModal(per);
              },
            });
          });
        }
        choices.push({ label: '돌아가기', sub: '', action: () => {} });
        const al = affLabel(per.affinity);
        showModal(
          `// ${per.name}과(와) 거래`,
          `호감도: ${per.affinity} (${al.txt}) · ${per.name}의 돈: ${per.money}원`,
          choices,
        );
      }

      // ── ROB MODAL ──
      function doRobModal() {
        const p = G.p;
        const here = G.people.filter(
          (x) =>
            x.alive &&
            x.loc === p.loc &&
            x.id !== 'daegyeom' &&
            x.affinity < 30,
        );
        if (!here.length) {
          toast('이 구역에 표적이 없다', 'err');
          return;
        }
        const choices = here.slice(0, 3).map((per) => ({
          label: `${per.name} 협박 (${per.group})`,
          sub: `위험도: ${per.trait === 'aggressive' ? '매우 높음' : '보통'} · 예상 ${per.money > 300 ? '돈+' : '식량+'}`,
          action: () => {
            const weapBonus = p.weapon ? 0.2 : 0;
            const skillBonus2 = skillBonus('combat', 0.1);
            const chance =
              0.45 +
              weapBonus +
              skillBonus2 -
              (per.trait === 'aggressive' ? 0.2 : 0);
            if (rr() < chance) {
              const cash = Math.min(per.money, r(120) + 40);
              const fCount = npcItemCount(per, 'food_ration');
              const food = rr() < 0.4 ? Math.min(fCount, r(2) + 1) : 0;
              per.money -= cash;
              for (let i = 0; i < food; i++) npcRemoveItem(per, 'food_ration');
              p.money += cash;
              addItem('food_ration', food);
              if (food) G.world.totalFood += food;
              p.rep = clamp(p.rep - 12, 0, 100);
              changeAff(per.id, -30);
              p.robbedCount++;
              p.sanity = clamp(p.sanity - 8, 0, 100);
              gainXp('combat', 5);
              log(
                `${per.name} 협박 성공. ${cash}원${food ? `, 식량 ${food}개` : ''}. 평판-12`,
                'da',
              );
            } else {
              const dmg = r(15) + 8;
              p.hp = Math.max(0, p.hp - dmg);
              p.injured = true;
              p.rep = clamp(p.rep - 5, 0, 100);
              log(`${per.name}이 저항했다. HP -${dmg}. 부상.`, 'da');
            }
          },
        }));
        choices.push({
          label: '창고/교무실 절도',
          sub: '현재 위치에서 물자 절도 시도',
          action: () => {
            const room = ROOMS[p.loc];
            if (room.food > 0 && rr() < 0.5 + skillBonus('stealth', 0.1)) {
              const f = r(3) + 1;
              addItem('food_ration', f);
              G.world.totalFood += f;
              room.food = Math.max(0, room.food - f);
              log(`${room.name}에서 식량 ${f}개 절도. 미발각.`, 'ok');
              gainXp('stealth', 6);
            } else {
              const dmg = r(8) + 5;
              p.hp = Math.max(0, p.hp - dmg);
              p.rep = clamp(p.rep - 15, 0, 100);
              log(`${room.name} 절도 실패. 들켰다. HP -${dmg} 평판-15`, 'da');
            }
          },
        });
        choices.push({ label: '취소', sub: '', action: () => {} });
        showModal('// 약탈/협박', '도덕적 경계를 넘으려 한다.', choices);
      }

      // ── GANG MODAL ──
      function doGangModal() {
        const p = G.p;
        if (p.ganged) {
          showModal(
            '// 세력 관리',
            `현재 세력: ${p.gangName}\n\n세력에서의 활동을 선택하라.`,
            [
              {
                label: '세력 임무 수행',
                sub: `돈 +80~150, 피로 +20`,
                action: () => {
                  p.fatigue = clamp(p.fatigue + 20, 0, 100);
                  const pay = r(70) + 80;
                  p.money += pay;
                  G.world.order = clamp(G.world.order - 3, 0, 100);
                  log(`세력 임무 완료. ${pay}원 수령.`, 'ok');
                  gainXp('combat', 4);
                },
              },
              {
                label: '세력 정보 공유',
                sub: '정보 1개를 세력에 줌. 평판+',
                action: () => {
                  if (!p.knownInfo.length) {
                    toast('공유할 정보 없음', 'err');
                    return;
                  }
                  p.rep = clamp(p.rep + 8, 0, 100);
                  log(`세력에 정보를 공유했다. 평판 +8`, 'ok');
                },
              },
              {
                label: '세력 탈퇴',
                sub: '평판-20',
                action: () => {
                  p.ganged = false;
                  const old = p.gangName;
                  p.gangName = null;
                  p.rep = clamp(p.rep - 20, 0, 100);
                  log(`${old}에서 탈퇴했다. 평판 -20`, 'na');
                },
              },
              { label: '닫기', sub: '', action: () => {} },
            ],
          );
          return;
        }
        showModal('// 세력 가담', '세 개의 주요 세력이 있다.', [
          {
            label: '불량배 무리에 가담 (강태호)',
            sub: '식량 3개, 보호. 위험한 임무, 평판-',
            action: () => {
              addItem('food_ration', 3);
              G.world.totalFood += 3;
              p.ganged = true;
              p.gangName = '불량배 무리';
              p.rep = clamp(p.rep - 15, 0, 100);
              log('불량배 무리에 가담. 식량 3개 수령. 평판-15.', 'na');
            },
          },
          {
            label: '모범생 연합 (정유진)',
            sub: '평판+15, 정보 공유. 약함',
            disabled: G.p.rep < 30,
            action: () => {
              if (p.rep < 30) {
                toast('평판 30 필요', 'err');
                return;
              }
              p.rep = clamp(p.rep + 15, 0, 100);
              p.ganged = true;
              p.gangName = '모범생 연합';
              learnInfo('ration_schedule');
              learnInfo('exit_plan');
              log('모범생 연합 합류. 평판+15. 정보 획득.', 'ok');
            },
          },
          {
            label: '학생회 (문하영)',
            sub: '조직력, 외교. 평판 40 필요',
            disabled: G.p.rep < 40,
            action: () => {
              if (p.rep < 40) {
                toast('평판 40 필요', 'err');
                return;
              }
              p.ganged = true;
              p.gangName = '학생회';
              p.rep = clamp(p.rep + 10, 0, 100);
              p.money += 200;
              log('학생회에 합류. 평판+10. 200원 수령.', 'ok');
            },
          },
          {
            label: '자체 세력 결성',
            sub: '평판 55, 동맹 2명 필요',
            action: () => {
              const allies = G.people.filter(
                (x) => x.alive && x.affinity >= 30,
              );
              if (p.rep < 55 || allies.length < 2) {
                toast(
                  `평판 55, 동맹 2명 필요 (현재 평판${p.rep}, 동맹${allies.length}명)`,
                  'err',
                );
                return;
              }
              p.ganged = true;
              p.gangName = '자유 연합';
              p.rep = clamp(p.rep + 20, 0, 100);
              log('자유 연합 결성. 평판+20.', 'ok');
            },
          },
          { label: '닫기', sub: '', action: () => {} },
        ]);
      }

      // ── CRAFT MODAL ──
      function doCraftModal() {
        const p = G.p;
        showModal('// 제작/업그레이드', '재료를 이용해 아이템을 만든다.', [
          {
            label: '임시 무기 (200원) → 파이프',
            sub: p.weapon ? '무기 이미 있음' : '',
            action: () => {
              if (p.weapon) {
                toast('무기 이미 있음', 'err');
                return;
              }
              if (p.money < 200) {
                toast('돈 부족', 'err');
                return;
              }
              p.money -= 200;
              addItem('pipe');
              p.weapon = 'pipe';
              log('파이프 무기 제작 (200원). 장착.', 'ok');
              gainXp('combat', 5);
            },
          },
          {
            label: `화염병 제작 (라이터+화학약품)`,
            sub:
              hasItem('lighter') && hasItem('chemicals')
                ? '재료 있음'
                : '라이터, 화학약품 필요',
            action: () => {
              if (!hasItem('lighter') || !hasItem('chemicals')) {
                toast('재료 부족', 'err');
                return;
              }
              removeItem('lighter');
              removeItem('chemicals');
              addItem('molotov');
              log('화염병 제작. 전투에서 강력하다.', 'ok');
              gainXp('combat', 8);
            },
          },
          {
            label: `방독면 제작 (천+화학약품)`,
            sub: hasItem('chemicals') ? '화학약품 있음' : '화학약품 필요',
            action: () => {
              if (!hasItem('chemicals')) {
                toast('재료 부족', 'err');
                return;
              }
              removeItem('chemicals');
              addItem('gas_mask');
              log('방독면 제작. 화학 가스 방어.', 'ok');
              gainXp('survival', 8);
            },
          },
          {
            label: `라디오 수리 (100원)`,
            sub: '외부 정보 수신',
            action: () => {
              if (p.money < 100) {
                toast('돈 부족', 'err');
                return;
              }
              p.money -= 100;
              addItem('radio');
              log('라디오 수리 완료. 외부 신호를 잡을 수 있다.', 'ok');
              gainXp('intel', 10);
              log('[라디오] "...구조대 파견 예정... 3일...잡음..."', 'in');
            },
          },
          {
            label: `불 피우기 (라이터)`,
            sub: hasItem('lighter') ? '라이터 있음' : '라이터 필요',
            action: () => {
              if (!hasItem('lighter')) {
                toast('라이터 없음', 'err');
                return;
              }
              p.sanity = clamp(p.sanity + 10, 0, 100);
              p.fatigue = clamp(p.fatigue - 8, 0, 100);
              if (p.cold) p.cold = false;
              log('불을 피웠다. 따뜻하다. 심리+10', 'ok');
            },
          },
          { label: '취소', sub: '', action: () => {} },
        ]);
      }

      // ── USE ITEM ──
      function useItem(id) {
        const p = G.p;
        const def = ITEMS[id];
        if (!hasItem(id)) {
          toast('없는 아이템', 'err');
          return;
        }
        switch (id) {
          case 'first_aid':
            removeItem('first_aid');
            p.hp = clamp(p.hp + 30, 0, p.maxhp);
            p.injured = false;
            log('구급키트 사용. HP+30', 'ok');
            gainXp('medical', 8);
            break;
          case 'antibiotics':
            removeItem('antibiotics');
            p.sick = false;
            p.infected = false;
            p.hp = clamp(p.hp + 10, 0, p.maxhp);
            log('항생제 투여. 감염/병 치료', 'ok');
            gainXp('medical', 6);
            break;
          case 'rope':
            toast('탈출 이벤트에서 사용됨', '');
            break;
          case 'lighter':
            toast('제작 메뉴에서 사용', '');
            break;
          case 'warm_clothes':
            if (!p.armor) {
              p.armor = true;
              p.cold = false;
              log('두꺼운 옷 착용. 추위 저항.', 'ok');
            } else toast('이미 착용 중', '');
            break;
          case 'sleeping_pills':
            toast('대겸 이벤트에서 사용됨', 'dg');
            break;
          case 'daegyeom_note':
            toast('대겸 이벤트에서 중요한 아이템', 'dg');
            break;
          case 'phone':
            p.sanity = clamp(p.sanity + 5, 0, 100);
            removeItem('phone');
            log(
              '[죽은 폰] "엄마" 라는 문자 초안이 저장되어 있었다. 보내지 못했다.',
              'na',
            );
            break;
          case 'radio':
            gainXp('intel', 3);
            log('[라디오] 잡음 속에서 희미한 신호가 들린다.', 'in');
            break;
          case 'notebook':
            learnInfo('daegyeom_past');
            gainXp('intel', 5);
            removeItem('notebook');
            log('노트를 읽었다. 대겸에 관한 내용이 있었다.', 'ev');
            break;
          default:
            toast(def ? def.name + ' 사용불가' : '알 수 없음', 'err');
        }
        checkDeath();
        fullUpdate();
      }

      // ── CHAR SPECIAL SKILL ──
      function doCharSkill() {
        const p = G.p;
        if (p.specialCooldown > 0) {
          toast(`특수 능력 쿨다운: ${p.specialCooldown}초`, 'err');
          return;
        }
        switch (p.charClass) {
          case 'excley': {
            // Miss Excley: 교사 권위 - NPC들을 명령할 수 있음
            showModal('// 교사 권위', '권위를 이용해 NPC를 통제한다.', [
              {
                label: '학생들에게 배급 명령',
                sub: '치안+8, 평판+10',
                action: () => {
                  G.world.order = clamp(G.world.order + 8, 0, 100);
                  p.rep = clamp(p.rep + 10, 0, 100);
                  log('[특수] 교사 권위로 배급 질서를 유지시켰다.', 'ok');
                  p.specialCooldown = 20;
                },
              },
              {
                label: 'NPC 정보 강제 수집',
                sub: '임의 NPC 정보 2개 획득',
                action: () => {
                  let got = 0;
                  G.people
                    .filter((x) => x.alive && x.info.length)
                    .forEach((x) => {
                      if (got < 2) {
                        const u = x.info.filter(
                          (i) => !p.knownInfo.includes(i),
                        );
                        if (u.length) {
                          learnInfo(u[0]);
                          got++;
                        }
                      }
                    });
                  log(`[특수] 교사 권위로 정보 ${got}개 획득.`, 'ok');
                  p.specialCooldown = 25;
                },
              },
              { label: '닫기', sub: '', action: () => {} },
            ]);
            break;
          }
          case 'junkyu': {
            // 우준규: 과학 실험 - 특수 아이템 제작
            if (!p.loc === 'science_lab' && !p.loc === 'classroom_a') {
              showModal('// 과학 실험', '과학 지식으로 특수 아이템을 만든다.', [
                {
                  label: '마취제 합성 (화학약품)',
                  sub: hasItem('chemicals') ? '재료 있음' : '화학약품 필요',
                  action: () => {
                    if (!hasItem('chemicals')) {
                      toast('화학약품 없음', 'err');
                      return;
                    }
                    removeItem('chemicals');
                    addItem('sleeping_pills', 2);
                    log('[특수] 화학약품으로 마취제 2개 합성.', 'ok');
                    gainXp('intel', 15);
                    p.specialCooldown = 30;
                  },
                },
                {
                  label: '정수 필터 제작',
                  sub: '물 소비량 -50% (1회성)',
                  action: () => {
                    p.thirst = clamp(p.thirst - 30, 0, 100);
                    log('[특수] 정수 필터로 물 정화. 갈증 -30.', 'ok');
                    p.specialCooldown = 20;
                  },
                },
                {
                  label: '독소 탐지',
                  sub: '정보 신뢰도 확인 (거짓 정보 탐지)',
                  action: () => {
                    const fakes = p.knownInfo.filter(
                      (id) => INFO_DB[id] && !INFO_DB[id].true,
                    );
                    if (fakes.length) {
                      log(
                        `[특수] 거짓 정보 발견: ${fakes.map((id) => INFO_DB[id].text.slice(0, 20) + '...').join(', ')}`,
                        'in',
                      );
                    } else log('[특수] 현재 보유 정보 중 거짓은 없다.', 'ok');
                    gainXp('intel', 12);
                    p.specialCooldown = 15;
                  },
                },
                { label: '닫기', sub: '', action: () => {} },
              ]);
            } else {
              log('[특수] 과학 실험실 또는 교실에서 사용 가능.', 'sy');
            }
            break;
          }
          case 'sebastian': {
            // 세바스찬: 가디언 - 전투/보호 특화
            showModal('// 가디언', '보호자 본능이 발동했다.', [
              {
                label: '순찰 실시',
                sub: '치안+12, 인근 NPC 보호',
                action: () => {
                  G.world.order = clamp(G.world.order + 12, 0, 100);
                  const nearNpc = G.people.filter(
                    (x) => x.alive && x.loc === p.loc,
                  );
                  nearNpc.forEach((n) => {
                    n.hp = Math.min(n.maxhp, n.hp + 5);
                    changeAff(n.id, 5);
                  });
                  log(
                    `[특수] 순찰 실시. 치안+12. ${nearNpc.length}명 보호.`,
                    'ok',
                  );
                  gainXp('combat', 10);
                  p.specialCooldown = 25;
                },
              },
              {
                label: '위협 제압',
                sub: '현재 구역 위험도 감소',
                action: () => {
                  const room = ROOMS[p.loc];
                  room.dangerLevel = Math.max(0, room.dangerLevel - 2);
                  G.world.order = clamp(G.world.order + 6, 0, 100);
                  log(`[특수] ${room.name} 위협 제압. 위험도 감소.`, 'ok');
                  gainXp('combat', 8);
                  p.specialCooldown = 20;
                },
              },
              { label: '닫기', sub: '', action: () => {} },
            ]);
            break;
          }
          case 'shinwon': {
            // 박신원: 체력 - 극한 상황 돌파
            showModal('// 체력 폭발', '극한의 체력으로 돌파한다.', [
              {
                label: '강제 탐색',
                sub: '피로 무시, 현재 구역 완전 탐색',
                action: () => {
                  const room = ROOMS[p.loc];
                  if (room.food > 0) {
                    const f = room.food;
                    addItem('food_ration', f);
                    G.world.totalFood += f;
                    room.food = 0;
                    log(`[특수] 강제 탐색. 식량 ${f}개 전량 회수.`, 'ok');
                  }
                  if (room.items && room.items.length) {
                    room.items.forEach((i) => addItem(i));
                    log(
                      `[특수] 아이템 ${room.items.length}개 전량 회수.`,
                      'ok',
                    );
                    room.items = [];
                  }
                  gainXp('survival', 15);
                  gainXp('strength', 8);
                  p.specialCooldown = 30;
                },
              },
              {
                label: '단거리 질주',
                sub: '인접 구역 2개 동시 이동',
                action: () => {
                  const conns = ROOM_CONNECTIONS[p.loc] || [];
                  if (!conns.length) {
                    toast('이동할 구역 없음', 'err');
                    return;
                  }
                  const dest = conns[r(conns.length)];
                  p.loc = dest;
                  p.fatigue = clamp(p.fatigue + 5, 0, 100);
                  const conns2 = ROOM_CONNECTIONS[dest] || [];
                  if (conns2.length) {
                    const dest2 = conns2[r(conns2.length)];
                    p.loc = dest2;
                    log(
                      `[특수] 질주: ${ROOMS[dest].name} → ${ROOMS[dest2].name}`,
                      'ok',
                    );
                  }
                  gainXp('agility', 12);
                  p.specialCooldown = 20;
                },
              },
              { label: '닫기', sub: '', action: () => {} },
            ]);
            break;
          }
          case 'moongaleb': {
            p.sanity = clamp(p.sanity + 12, 0, 100);
            const nearNpc = G.people.filter((x) => x.alive && x.loc === p.loc);
            nearNpc.forEach((n) => changeAff(n.id, 8));
            log(
              `[특수] 비트 드랍! 정신력 +12. ${nearNpc.length}명의 호감도 상승.`,
              'ok',
            );
            p.specialCooldown = 20;
            break;
          }
          case 'mincheol': {
            const nearNpc = G.people.filter(
              (x) => x.alive && x.loc === p.loc && x.id !== 'daegyeom',
            );
            if (nearNpc.length) {
              log(`[특수] 시장 간파:`, 'in');
              nearNpc.forEach((n) => {
                const items = n.inventory || [];
                log(`> ${n.name}: 아이템 ${items.length}개 보유 중.`, 'sy');
              });
            } else log('[특수] 주변에 거래할 인물이 없다.', 'sy');
            p.specialCooldown = 15;
            break;
          }
          case 'taichi': {
            p.hp = clamp(p.hp + 25, 0, p.maxhp);
            p.sanity = clamp(p.sanity + 10, 0, 100);
            log(`[특수] 카나소바 투지! HP +25, 정신력 +10.`, 'ok');
            p.specialCooldown = 30;
            break;
          }
          case 'yejun': {
            const win = rr() < 0.45;
            if (win) {
              const gain = 500 + r(500);
              p.money += gain;
              log(`[특수] 올인 성공! ${gain}원을 땄다!`, 'ok');
            } else {
              const loss = Math.min(p.money, 300);
              p.money -= loss;
              p.hp -= 10;
              log(`[특수] 올인 실패... ${loss}원을 잃었다. HP -10`, 'da');
            }
            p.specialCooldown = 25;
            break;
          }
          case 'heejae': {
            const nearNpc = G.people.filter(
              (x) =>
                x.alive &&
                x.loc === p.loc &&
                x.id !== 'daegyeom' &&
                !x.id.startsWith('anon'),
            );
            if (nearNpc.length) {
              const target = nearNpc[r(nearNpc.length)];
              changeAff(target.id, 25);
              if (rr() < 0.3) {
                addItem('food_ration');
                log(
                  `[특수] 매혹의 눈빛. ${target.name}의 호감도 급상승! 식량을 선물로 받았다.`,
                  'ok',
                );
              } else {
                log(
                  `[특수] 매혹의 눈빛. ${target.name}의 호감도 급상승!`,
                  'ok',
                );
              }
            } else log('[특수] 매혹할 대상이 없다.', 'sy');
            p.specialCooldown = 20;
            break;
          }
          default:
            toast('특수 능력 없음', 'err');
        }
      }

      // ═══════════════════════════════════════
      // TIMER
      // ═══════════════════════════════════════
      function startTimer() {
        G.timer = setInterval(tick, 1000);
      }
      function tick() {
        if (G.over || G.paused) return;
        G.time++;
        if (G.p.specialCooldown > 0) G.p.specialCooldown--;
        // Phase
        if (G.time === 25) changePhase('afternoon');
        if (G.time === 50) changePhase('night');
        if (G.time >= G.dayLen) {
          updateGlobalResources();
          endDay();
          return;
        }

        // NPC Survival Loop (every 10 ticks)
        if (G.time % 10 === 0) {
          G.people.forEach((p) => {
            if (!p.alive || p.id === 'daegyeom' || p.id === 'player') return;

            // Hunger/Thirst Decay
            p.hunger = clamp((p.hunger || 0) + 4, 0, 100);
            p.thirst = clamp((p.thirst || 0) + 5, 0, 100);

            // Consumption Logic
            if (p.hunger > 60) {
              const foodIdx = (p.inventory || []).indexOf('food_ration');
              if (foodIdx > -1) {
                p.inventory.splice(foodIdx, 1);
                p.hunger = clamp(p.hunger - 40, 0, 100);
                if (p.loc === G.p.loc)
                  log(`${p.name}이 배고픔에 식량을 먹었다.`, 'sy');
              }
            }
            if (p.thirst > 60) {
              const waterIdx = (p.inventory || []).indexOf('water_bottle');
              if (waterIdx > -1) {
                p.inventory.splice(waterIdx, 1);
                p.thirst = clamp(p.thirst - 50, 0, 100);
                if (p.loc === G.p.loc) log(`${p.name}이 목을 축였다.`, 'sy');
              }
            }

            // Death Logic
            if (p.hunger >= 100 || p.thirst >= 100) {
              p.alive = false;
              p.hp = 0;
              G.world.deaths++;
              // Drop items back to room
              const room = ROOMS[p.loc];
              if (room && p.inventory) {
                room.items = room.items.concat(p.inventory);
                p.inventory = [];
              }
              log(
                `💀 [${ROOMS[p.loc].name}] ${p.name}이 굶주림/탈수로 사망했다.`,
                'dg',
              );
            }

            // NPC Auto Trading (NPC with money and hunger buys from NPC with food in same room)
            if (p.alive && (p.hunger > 50 || p.thirst > 50) && p.money > 100) {
              const others = G.people.filter(
                (x) =>
                  x.alive &&
                  x.loc === p.loc &&
                  x.id !== p.id &&
                  x.id !== 'player',
              );
              for (const other of others) {
                if (p.hunger > 50) {
                  const foodIdx = (other.inventory || []).indexOf(
                    'food_ration',
                  );
                  if (foodIdx > -1) {
                    const price = 100 + r(50);
                    if (p.money >= price) {
                      p.money -= price;
                      other.money += price;
                      other.inventory.splice(foodIdx, 1);
                      (p.inventory = p.inventory || []).push('food_ration');
                      if (p.loc === G.p.loc)
                        log(
                          `[거래] ${p.name}이(가) ${other.name}에게서 식량을 샀다.`,
                          'sy',
                        );
                      break;
                    }
                  }
                }
                if (p.thirst > 50) {
                  const waterIdx = (other.inventory || []).indexOf(
                    'water_bottle',
                  );
                  if (waterIdx > -1) {
                    const price = 60 + r(30);
                    if (p.money >= price) {
                      p.money -= price;
                      other.money += price;
                      other.inventory.splice(waterIdx, 1);
                      (p.inventory = p.inventory || []).push('water_bottle');
                      if (p.loc === G.p.loc)
                        log(
                          `[거래] ${p.name}이(가) ${other.name}에게서 물을 샀다.`,
                          'sy',
                        );
                      break;
                    }
                  }
                }
              }
            }

            // Autonomous NPC Skills
            if (p.alive) {
              if (p.role === 'thief' && G.time % 30 === 0) {
                const targets = G.people.filter(
                  (x) =>
                    x.alive &&
                    x.loc === p.loc &&
                    x.id !== p.id &&
                    x.inventory &&
                    x.inventory.length > 0,
                );
                if (targets.length) {
                  const target = targets[r(targets.length)];
                  const itemIdx = r(target.inventory.length);
                  const item = target.inventory.splice(itemIdx, 1)[0];
                  p.inventory.push(item);
                  if (target.id === 'player')
                    log(
                      `[경고] 누군가 소지품에서 ${ITEMS[item].name}을 훔쳐갔다!`,
                      'da',
                    );
                  else if (p.loc === G.p.loc)
                    log(
                      `[목격] ${p.name}이(가) ${target.name}의 물건을 슬쩍하는 걸 보았다.`,
                      'sy',
                    );
                }
              }
              if (p.role === 'merchant' && G.time % 40 === 0) {
                const rareItems = [
                  'gas_mask',
                  'radio',
                  'first_aid',
                  'antibiotics',
                  'canned_food',
                ];
                const newItem = rareItems[r(rareItems.length)];
                p.inventory.push(newItem);
                if (p.loc === G.p.loc)
                  log(
                    `[소문] ${p.name}이(가) 새로운 물건을 입고했다는 것 같다.`,
                    'sy',
                  );
              }
              if (p.role === 'animal' && G.time % 20 === 0) {
                if (rr() < 0.3) {
                  p.inventory.push('food_ration');
                  if (p.loc === G.p.loc)
                    log(`[관찰] 고양이가 쥐를 잡아와서 먹고 있다.`, 'ok');
                } else if (p.loc === G.p.loc)
                  log(`[관찰] 고양이가 미야옹거린다.`, 'sy');
              }
              if (p.id === 'tiffany' && G.time % 20 === 0) {
                const nearMales = G.people.filter(
                  (x) =>
                    x.alive && x.loc === p.loc && x.role.includes('student_m'),
                );
                if (nearMales.length) {
                  const target = nearMales[r(nearMales.length)];
                  target.affinity = clamp(
                    (target.affinity || 0) + 10,
                    -100,
                    100,
                  );
                  if (rr() < 0.2) {
                    const foodIdx = (target.inventory || []).indexOf(
                      'food_ration',
                    );
                    if (foodIdx > -1) {
                      target.inventory.splice(foodIdx, 1);
                      p.inventory.push('food_ration');
                      if (p.loc === G.p.loc)
                        log(
                          `[목격] ${target.name}이 티파니에게 식량을 건네주며 수줍어한다.`,
                          'ok',
                        );
                    }
                  }
                }
              }
            }
          });
          updateGlobalResources();
        }

        // Passive decay (every 8s)
        if (G.time % 8 === 0) {
          G.p.hunger = clamp(G.p.hunger + 3, 0, 100);
          G.p.thirst = clamp(G.p.thirst + 4, 0, 100);
          G.p.fatigue = clamp(G.p.fatigue + 1, 0, 100);
          if (G.p.hunger > 85) G.p.hp = Math.max(0, G.p.hp - 3);
          if (G.p.thirst > 85) G.p.hp = Math.max(0, G.p.hp - 4);
          if (G.p.sick) G.p.hp = Math.max(0, G.p.hp - 2);
          if (G.p.infected) G.p.hp = Math.max(0, G.p.hp - 3);
          if (G.p.cold && !G.p.armor) G.p.hp = Math.max(0, G.p.hp - 2);
          if (G.world.temp < -7 && !hasItem('warm_clothes') && !G.p.armor) {
            G.p.cold = true;
          }
          if (G.p.sanity < 20) G.p.hp = Math.max(0, G.p.hp - 1);
          checkDeath();
        }
        // Random events
        if (G.world.randCooldown > 0) G.world.randCooldown--;
        if (G.world.randCooldown === 0 && rr() < 0.02) {
          triggerRandEv();
          G.world.randCooldown = 12;
        }
        // DG messages
        if (
          G.world.dgStage >= 2 &&
          rr() < 0.008 &&
          !document.getElementById('dgphone').classList.contains('active')
        ) {
          triggerDgMsg();
        }
        // Chaos trigger
        if (!G.world.chaos) {
          const princ = gp('principal');
          if (princ && !princ.alive) {
            G.world.chaos = true;
            log('⚠️ 교장이 죽었다. 학교의 마지막 질서가 무너졌다.', 'dg');
            log('학생들 사이에 불신과 폭력이 싹트기 시작했다.', 'da');
            G.world.order = Math.max(0, G.world.order - 30);
          }
        }

        // NPC Infighting (every 16 ticks during Chaos)
        if (G.world.chaos && G.time % 16 === 0) {
          const locs = Object.keys(ROOMS).filter((l) => !ROOMS[l].safe);
          locs.forEach((l) => {
            const folks = G.people.filter(
              (x) =>
                x.alive &&
                x.loc === l &&
                x.id !== 'daegyeom' &&
                x.id !== 'player',
            );
            if (folks.length >= 2 && rr() < 0.15 + G.world.chaosLevel * 0.05) {
              // A fight breaks out
              const p1 = folks[r(folks.length)];
              const p2 = folks.filter((x) => x.id !== p1.id)[
                r(folks.length - 1)
              ];

              const p1Win = rr() < 0.5;
              const loser = p1Win ? p2 : p1;
              const winner = p1Win ? p1 : p2;

              const dmg = r(20) + 10;
              loser.hp -= dmg;

              if (loser.loc === G.p.loc) {
                log(
                  `⚔️ [${ROOMS[l].name}] ${p1.name}와 ${p2.name}이 식량을 두고 싸우고 있다!`,
                  'da',
                );
                if (!G.p.hiding) {
                  const pDmg = r(10) + 5;
                  G.p.hp -= pDmg;
                  log(`싸움에 휘말렸다! HP -${pDmg}`, 'da');
                }
              }

              if (loser.hp <= 0) {
                loser.alive = false;
                G.world.deaths++;
                const items = loser.inventory || [];
                if (items.length > 0) {
                  if (winner.id.startsWith('anon')) {
                    // Anon loot drops to room
                    ROOMS[l].items = ROOMS[l].items.concat(items);
                    if (loser.loc === G.p.loc)
                      log(
                        `💀 ${loser.name}이 사망했다. 물건들이 바닥에 흩어졌다.`,
                        'da',
                      );
                  } else {
                    // Named killer takes loot
                    winner.inventory = (winner.inventory || []).concat(items);
                    if (loser.loc === G.p.loc)
                      log(
                        `💀 ${loser.name}이 사망했다. ${winner.name}이 그의 물건을 챙겼다.`,
                        'da',
                      );
                  }
                  loser.inventory = [];
                }
              }
            }
          });
          G.world.chaosLevel = Math.min(10, G.world.chaosLevel + 0.1);
        }

        // Daegyeom movement (every 12 ticks, night or dgStage>=3)
        if (
          G.time % 12 === 0 &&
          (G.phase === 'night' || G.world.dgStage >= 3)
        ) {
          const dg = gp('daegyeom');
          if (dg && dg.alive && dg.loc !== 'unknown') {
            const conns = ROOM_CONNECTIONS[dg.loc] || [];
            if (conns.length > 0) {
              const oldLoc = dg.loc;
              dg.loc = conns[r(conns.length)];
              // Check if Daegyeom entered player's room
              if (dg.loc === G.p.loc) {
                const room = ROOMS[G.p.loc];
                if (G.p.hiding && room && room.hideSpot) {
                  const bonus = skillBonus('stealth', 0.1);
                  const chance = Math.min(0.95, room.hideChance + bonus);
                  if (rr() < chance) {
                    log(
                      '⚠️ 대겸이 이 구역을 지나갔다. 숨어서 들키지 않았다.',
                      'ev',
                    );
                  } else {
                    G.p.hiding = false;
                    log('⚠️ 대겸이 너를 발견했다!', 'dg');
                    daegyeomEncounter();
                  }
                } else {
                  log('⚠️ 대겸이 나타났다!', 'dg');
                  daegyeomEncounter();
                }
              }
            }
          }
        }
        updateStats();
        updateWorld();
      }
      function daegyeomEncounter() {
        const p = G.p;
        const room = ROOMS[p.loc];
        const conns = ROOM_CONNECTIONS[p.loc] || [];
        const choices = [];
        // Flee
        if (conns.length > 0) {
          choices.push({
            label: '도망치기',
            sub: `민첩 보너스 적용. 성공률: ${Math.floor(40 + skillBonus('agility', 15))}%`,
            action: () => {
              const chance = 0.4 + skillBonus('agility', 0.15);
              if (rr() < chance) {
                const dest = conns[r(conns.length)];
                p.loc = dest;
                log(`도망쳤다! ${ROOMS[dest].name}(으)로 이동.`, 'ok');
                gainXp('agility', 8);
              } else {
                const dmg = r(20) + 15;
                p.hp = Math.max(0, p.hp - dmg);
                p.injured = true;
                p.sanity = clamp(p.sanity - 10, 0, 100);
                log(`도망 실패. 대겸에게 공격당했다. HP -${dmg}`, 'dg');
              }
            },
          });
        }
        // Fight
        choices.push({
          label: '맞서 싸우기',
          sub: '전투 + 무기 보너스 적용. 위험하다.',
          dg: true,
          action: () => {
            const wpnBonus =
              p.weapon === 'bat'
                ? 15
                : p.weapon === 'knife'
                  ? 10
                  : p.weapon === 'pipe'
                    ? 8
                    : 0;
            const chance = 0.2 + skillBonus('combat', 0.15) + wpnBonus / 100;
            if (rr() < chance) {
              const dmg = r(15) + 10;
              const dg = gp('daegyeom');
              if (dg) dg.hp -= dmg;
              log(`대겸에게 반격! ${dmg} 데미지. 대겸이 물러났다.`, 'ok');
              p.rep = clamp(p.rep + 10, 0, 100);
              gainXp('combat', 12);
            } else {
              const dmg = r(30) + 20;
              p.hp = Math.max(0, p.hp - dmg);
              p.injured = true;
              p.sanity = clamp(p.sanity - 15, 0, 100);
              log(`대겸에게 패배했다. HP -${dmg}. 심각한 부상.`, 'dg');
            }
          },
        });
        // Negotiate (if has info items)
        if (hasItem('daegyeom_note') || hasItem('notebook')) {
          choices.push({
            label: '대화 시도',
            sub: '대겸의 메모가 있다. 그의 동기를 물을 수 있다.',
            action: () => {
              const dg = gp('daegyeom');
              if (dg) dg.affinity = clamp(dg.affinity + 15, -100, 100);
              p.sanity = clamp(p.sanity - 5, 0, 100);
              log('대겸과 대화했다. 그의 이유를 조금 이해했다...', 'ev');
              log(`"...모두가 날 무시했어. 이제는 내가 규칙을 정한다."`, 'dg');
              if (dg && dg.affinity >= 0) {
                log('대겸의 태도가 약간 누그러졌다.', 'ok');
              }
              gainXp('social', 10);
              gainXp('intel', 8);
            },
          });
        }
        showModal(
          '⚠️ 대겸 조우',
          `${room ? room.name : '???'}에서 대겸과 마주쳤다. 그의 눈이 차갑다.`,
          choices,
          true,
        );
      }

      // ═══════════════════════════════════════
      // PHASE CHANGE
      // ═══════════════════════════════════════
      function changePhase(ph) {
        G.phase = ph;
        const lb = { afternoon: '오후', night: '밤' };
        logGap();
        logSep(lb[ph]);
        if (ph === 'afternoon') {
          const msgs = [
            '오후가 됐다. 배급 줄이 더 길어졌다.',
            '오후. 사람들의 표정이 더 어두워졌다.',
          ];
          log(msgs[r(msgs.length)], 'sy');
          if (G.world.order < 50) log('어딘가서 고함이 들린다.', 'da');
          // NPC affinity drift
          G.people
            .filter((x) => x.alive && !x.id.startsWith('anon'))
            .forEach((x) => {
              if (x.affinity > 0) x.affinity = Math.max(-100, x.affinity - 1);
            });
        }
        if (ph === 'night') {
          log('밤이 됐다. 복도 불이 꺼지기 시작했다.', 'sy');
          G.p.fatigue = clamp(G.p.fatigue + 8, 0, 100);
          // Night theft
          if (
            rr() < 0.18 - skillBonus('stealth', 0.03) &&
            G.world.order < 50 &&
            !hasItem('lock')
          ) {
            const s = Math.min(G.p.money, r(90) + 15);
            if (s) {
              G.p.money -= s;
              log(`밤 사이 ${s}원이 없어졌다.`, 'da');
            }
          }
          // DG hunting at night
          if (G.world.dgStage >= 6 && rr() < 0.35) {
            triggerDgNightHunt();
          }
          // Temperature drops at night
          G.world.temp--;
          updateWorld();
        }
      }

      function triggerDgNightHunt() {
        log(
          '[대겸] 밤에 발소리가 들렸다. 천천히, 하지만 확실히 가까워지고 있다.',
          'dg',
        );
        G.p.sanity = clamp(G.p.sanity - 12, 0, 100);
        if (rr() < 0.4) {
          showModal(
            '// 발소리',
            '문 밖에서 발소리가 들린다.\n조용히 멈춰 있다.\n문손잡이가 움직인다.',
            [
              {
                label: '숨는다',
                sub: `은신 Lv${G.p.skills.stealth}`,
                action: () => {
                  const ch = 0.5 + skillBonus('stealth', 0.1);
                  if (rr() < ch) {
                    log('숨었다. 발소리가 멀어졌다.', 'ok');
                    gainXp('stealth', 10);
                  } else {
                    G.p.hp = clamp(G.p.hp - 20, 0, G.p.maxhp);
                    log('[대겸] "찾았다." — HP -20', 'dg');
                  }
                },
              },
              {
                label: '무기로 맞선다',
                sub: G.p.weapon ? '무기 있음' : '무기 없이 싸움',
                dg: false,
                action: () => {
                  const ch = G.p.weapon ? 0.45 : 0.2;
                  if (rr() < ch) {
                    G.p.hp = clamp(G.p.hp - 15, 0, G.p.maxhp);
                    log('싸워서 물리쳤다. HP -15', 'ok');
                    gainXp('combat', 12);
                  } else {
                    G.p.hp = clamp(G.p.hp - 35, 0, G.p.maxhp);
                    G.p.sanity = clamp(G.p.sanity - 20, 0, 100);
                    log('[대겸] 패배했다. HP -35. 심리 -20', 'dg');
                  }
                },
              },
              {
                label: '도망친다',
                sub: `민첩 Lv${G.p.skills.agility}`,
                action: () => {
                  const ch = 0.55 + skillBonus('agility', 0.1);
                  if (rr() < ch) {
                    const conns = ROOM_CONNECTIONS[G.p.loc] || [];
                    if (conns.length) {
                      G.p.loc = conns[r(conns.length)];
                      gainXp('agility', 8);
                    }
                    log('어떻게든 도망쳤다.', 'ok');
                  } else {
                    G.p.hp = clamp(G.p.hp - 10, 0, G.p.maxhp);
                    log('도망치다 다쳤다. HP -10', 'da');
                  }
                },
              },
            ],
            true,
          );
        }
      }

      // ═══════════════════════════════════════
      // DAY END
      // ═══════════════════════════════════════
      function endDay() {
        clearInterval(G.timer);
        G.time = 0;
        G.day++;
        G.phase = 'morning';
        // Auto-save at each day transition
        try {
          saveGame();
        } catch (e) {}
        G.p.specialUsesToday = 0;
        // World food consumption
        const alive = G.people.filter((p) => p.alive).length;
        const cons = Math.floor(alive * 0.65);
        G.world.totalFood = Math.max(0, G.world.totalFood - cons);
        // NPC deaths
        const daysLeft = alive > 0 ? G.world.totalFood / (alive * 0.65) : 0;
        if (daysLeft < 1.2) {
          const d = r(6) + 3;
          for (let i = 0; i < d; i++) {
            const victims = G.people.filter(
              (p) => p.alive && p.id !== 'daegyeom' && p.id !== 'player',
            );
            if (victims.length) {
              const v = victims[r(victims.length)];
              v.alive = false;
              G.world.deaths++;
            }
          }
          G.world.order = clamp(G.world.order - 10, 0, 100);
          log(`굶주림으로 ${d}명이 더 사망했다.`, 'de');
          G.p.sanity = clamp(G.p.sanity - 8, 0, 100);
        } else if (rr() < 0.3) {
          const d = r(2) + 1;
          for (let i = 0; i < d; i++) {
            const victims = G.people.filter(
              (p) => p.alive && p.id !== 'daegyeom' && p.id.startsWith('anon'),
            );
            if (victims.length) {
              const v = victims[r(victims.length)];
              v.alive = false;
              G.world.deaths++;
            }
          }
        }
        // Player daily
        G.p.hunger = clamp(G.p.hunger + 20, 0, 100);
        G.p.thirst = clamp(G.p.thirst + 25, 0, 100);
        G.p.fatigue = clamp(G.p.fatigue + 15, 0, 100);
        if (G.p.hunger > 70) G.p.hp = Math.max(0, G.p.hp - 6);
        if (G.p.thirst > 70) G.p.hp = Math.max(0, G.p.hp - 8);
        // XP for surviving a day
        G.p.sp += G.day % 3 === 0 ? 1 : 0;
        if (G.day % 3 === 0) {
          toast('SP +1 (생존 보상)', 'win');
          showLvFlash('SP +1');
        }
        // Temp
        if (G.day % 2 === 0) G.world.temp--;
        // DG progression
        progressDg();
        logGap();
        logSep('아침');
        log(
          `${G.day}일째. 생존자 ${G.people.filter((p) => p.alive).length}명.`,
          'in',
        );
        if (G.world.totalFood < 150) log('식량이 위험 수준으로 낮다.', 'da');
        if (G.world.temp < -6)
          log(`기온 ${G.world.temp}°C. 체감은 더 낮다.`, 'da');
        checkScheduled();
        checkDeath();
        checkEnding();
        if (!G.over) {
          fullUpdate();
          startTimer();
        }
      }

      // ═══════════════════════════════════════
      // DAEGYEOM PROGRESSION
      // ═══════════════════════════════════════
      function progressDg() {
        const s = G.world.dgStage;
        const d = G.day;
        if (s === 0 && d >= 2) {
          G.world.dgStage = 1;
          log('박대겸에 대한 이상한 소문이 돌기 시작했다.', 'ev');
        } else if (s === 1 && d >= 3) {
          G.world.dgStage = 2;
          setTimeout(() => {
            log('[알 수 없는 번호]에서 문자가 왔다.', 'dg');
          }, 1500);
        } else if (s === 2 && d >= 4) {
          G.world.dgStage = 3;
          setTimeout(killPrincipal, 2000);
        } else if (s === 3 && d >= 5) {
          G.world.dgStage = 4;
          setTimeout(killTeachers, 2000);
        } else if (s === 4 && d >= 6) {
          G.world.dgStage = 5;
          setTimeout(collapseRation, 2000);
        } else if (s === 5 && d >= 7) {
          G.world.dgStage = 6;
          setTimeout(dgHunting, 2000);
        } else if (s === 6 && d >= 9) {
          G.world.dgStage = 7;
          setTimeout(finalConfront, 3000);
        }
      }

      function killPrincipal() {
        const pr = gp('principal');
        if (pr) pr.alive = false;
        G.world.survivors--;
        G.world.order = clamp(G.world.order - 25, 0, 100);
        G.p.sanity = clamp(G.p.sanity - 15, 0, 100);
        logGap();
        log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'de');
        log('교장이 죽은 채 발견됐다. 교장실에서.', 'de');
        log('시신 상태는 끔찍했다고 한다.', 'de');
        log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'de');
        setTimeout(
          () =>
            showModal(
              '// 교장 사망',
              '교장 선생님이 사망했다.\n\n아침에 사무실에서 발견됐다. 아무도 소리를 못 들었다고 했다.\n\n이제 학교 최고 권위자가 없다.',
              [
                {
                  label: '침묵한다',
                  sub: '',
                  action: () => {
                    log('아무 말도 하지 않았다.', 'sy');
                  },
                },
                {
                  label: '목격자를 찾는다',
                  sub: '평판+, 정보 획득',
                  action: () => {
                    G.p.rep = clamp(G.p.rep + 5, 0, 100);
                    learnInfo('daegyeom_sighting');
                    gainXp('intel', 8);
                  },
                },
                {
                  label: '대겸을 직접 찾는다',
                  sub: '위험. 정보+',
                  action: () => {
                    G.p.sanity = clamp(G.p.sanity - 12, 0, 100);
                    G.p.hp = clamp(G.p.hp - 5, 0, G.p.maxhp);
                    log(
                      '대겸을 찾아갔다. 그는 창가에 혼자 있었다. 눈이 마주쳤다.',
                      'dg',
                    );
                    log('"왜 왔어?" 그 말이 차가웠다.', 'dgt');
                    learnInfo('daegyeom_plan');
                  },
                },
              ],
            ),
          1500,
        );
      }

      function killTeachers() {
        [
          'teacher_good1',
          'teacher_good2',
          'teacher_bad1',
          'teacher_bad2',
        ].forEach((id) => {
          if (rr() < 0.7) {
            const t = gp(id);
            if (t) t.alive = false;
          }
        });
        G.world.order = clamp(G.world.order - 20, 0, 100);
        G.p.sanity = clamp(G.p.sanity - 12, 0, 100);
        logGap();
        log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'de');
        log('밤사이 교사 여러 명이 추가 사망했다.', 'de');
        log('급식실 통제가 완전히 무너졌다.', 'de');
        log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'de');
        setTimeout(
          () =>
            showModal(
              '// 교사 연쇄 사망',
              '이제 학교에 어른이 없다.\n\n"이제 재밌어지겠지." — 대겸에게서 문자가 왔다.',
              [
                {
                  label: '문자 확인',
                  sub: '심리 -5',
                  dg: true,
                  action: () => {
                    G.p.sanity = clamp(G.p.sanity - 5, 0, 100);
                    log('[박대겸]: "교사들 없으니 더 좋지 않아?"', 'dgt');
                  },
                },
                {
                  label: '무시한다',
                  sub: '',
                  action: () => {
                    log('문자를 무시했다.', 'sy');
                  },
                },
              ],
              true,
            ),
          1500,
        );
      }

      function collapseRation() {
        G.world.order = clamp(G.world.order - 25, 0, 100);
        G.p.sanity = clamp(G.p.sanity - 10, 0, 100);
        logGap();
        log('공식 배급이 완전히 중단됐다.', 'da');
        log('이제 힘 있는 자만 식량을 가진다.', 'da');
        setTimeout(
          () =>
            showModal(
              '// 배급 붕괴',
              '모든 질서가 무너졌다.\n\n세 세력이 식량 창고를 두고 충돌하고 있다.',
              [
                {
                  label: '불량배 무리에 합류',
                  sub: '식량 3개, 위험한 임무',
                  action: () => {
                    addItem('food_ration', 3);
                    G.world.totalFood += 3;
                    G.p.ganged = true;
                    G.p.gangName = '불량배 무리';
                    G.p.rep = clamp(G.p.rep - 10, 0, 100);
                    log('불량배 무리에 합류. 식량 3개.', 'na');
                  },
                },
                {
                  label: '혼자 버틴다',
                  sub: '',
                  action: () => {
                    log('혼자 가기로 했다.', 'na');
                  },
                },
                {
                  label: '연합 결성 시도',
                  sub: '평판 45 필요',
                  action: () => {
                    if (G.p.rep < 45) {
                      toast('평판 부족', 'err');
                      return;
                    }
                    G.p.ganged = true;
                    G.p.gangName = '자유 연합';
                    G.p.rep = clamp(G.p.rep + 15, 0, 100);
                    log('자유 연합 결성. 평판+15.', 'ok');
                  },
                },
              ],
            ),
          1500,
        );
      }

      function dgHunting() {
        G.p.sanity = clamp(G.p.sanity - 18, 0, 100);
        logGap();
        log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'dg');
        log('[박대겸] 방송: "이제 찾아다닐게. 재밌을 것 같아서."', 'dg');
        log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'dg');
        setTimeout(
          () =>
            showModal(
              '// 박대겸의 방송',
              '"안녕.\n\n심심하던 참이었어.\n\n게임 하나 하자.\n내가 찾으면 네가 지는 거야."',
              [
                {
                  label: '숨을 곳을 마련한다',
                  sub: '피로+20, 안전↑',
                  action: () => {
                    G.p.fatigue = clamp(G.p.fatigue + 20, 0, 100);
                    G.p.sanity = clamp(G.p.sanity - 5, 0, 100);
                    log('어두운 창고 구석에 숨었다.', 'na');
                  },
                },
                {
                  label: '무기를 준비한다',
                  sub: G.p.weapon ? '무기 있음' : '무기 없이',
                  action: () => {
                    log('무기를 꽉 잡았다. 손이 떨렸다.', 'na');
                    if (!G.p.weapon) toast('무기가 없다', 'err');
                  },
                },
                {
                  label: '사람들에게 경고한다',
                  sub: '평판+8',
                  action: () => {
                    G.p.rep = clamp(G.p.rep + 8, 0, 100);
                    G.world.order = clamp(G.world.order - 5, 0, 100);
                    log('경고했지만 믿어주는 사람이 많지 않았다.', 'in');
                  },
                },
              ],
              true,
            ),
          1500,
        );
      }

      function finalConfront() {
        clearInterval(G.timer);
        G.paused = true;
        logGap();
        log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'dg');
        log('발소리가 들린다.', 'de');
        log('문손잡이가 돌아간다.', 'de');
        log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'dg');
        const p = G.p;
        const choices = [];
        // Fight
        choices.push({
          label: '싸운다',
          sub: `전투 성공률: ${Math.round((p.weapon ? 55 : 25) + skillBonus('combat', 5))}%`,
          dg: false,
          action: () => {
            G.paused = false;
            const ch = (p.weapon ? 0.55 : 0.25) + skillBonus('combat', 0.05);
            if (rr() < ch) {
              const dmg = p.weapon ? r(20) + 10 : r(35) + 15;
              p.hp = clamp(p.hp - dmg, 0, p.maxhp);
              if (p.hp > 0) showEnding('fight');
              else die('대겸과의 싸움에서 패배했다.');
            } else {
              p.hp = clamp(p.hp - 50, 0, p.maxhp);
              if (p.hp > 0) {
                log('[대겸]: "아직 살아있네."', 'dgt');
                G.world.dgStage = 6;
                G.paused = false;
                startTimer();
              } else die('대겸에게 패배했다.');
            }
          },
        });
        // Gang
        if (p.ganged) {
          choices.push({
            label: `${p.gangName} 지원 요청`,
            sub: '세력과 함께 맞선다',
            action: () => {
              G.paused = false;
              log(`${p.gangName}이 몰려왔다.`, 'ok');
              p.hp = clamp(p.hp - 10, 0, p.maxhp);
              showEnding('gang');
            },
          });
        }
        // Sleeping pills
        if (hasItem('sleeping_pills')) {
          choices.push({
            label: '수면제 사용',
            sub: '사전에 준비해 뒀다',
            action: () => {
              G.paused = false;
              removeItem('sleeping_pills');
              log('[대겸]이 쓰러졌다.', 'ok');
              showEnding('pills');
            },
          });
        }
        // Note
        if (hasItem('daegyeom_note')) {
          choices.push({
            label: '메모를 보여준다',
            sub: '약점을 찌른다',
            action: () => {
              G.paused = false;
              log('[대겸]의 표정이 굳었다.', 'dg');
              showEnding('note');
            },
          });
        }
        // High rep / network - talk him down
        if (p.rep >= 70 && p.skills.social >= 3) {
          choices.push({
            label: '설득한다',
            sub: `평판 70+, 사교 Lv3 이상`,
            action: () => {
              G.paused = false;
              if (rr() < 0.6) {
                log('"...이런 게 재밌어?" 대겸이 멈췄다.', 'dg');
                showEnding('talk');
              } else {
                p.hp = clamp(p.hp - 25, 0, p.maxhp);
                if (p.hp <= 0) die('설득 실패');
                else {
                  log('설득 실패. HP -25', 'da');
                  G.world.dgStage = 6;
                  G.paused = false;
                  startTimer();
                }
              }
            },
          });
        }
        // Rope escape
        if (hasItem('rope')) {
          choices.push({
            label: '탈출',
            sub: '밧줄로 창문 탈출',
            action: () => {
              G.paused = false;
              removeItem('rope');
              showEnding('escape');
            },
          });
        }
        choices.push({
          label: '도망친다',
          sub: '성공률 50%',
          action: () => {
            G.paused = false;
            if (rr() < 0.5 + skillBonus('agility', 0.05)) {
              const conns = ROOM_CONNECTIONS[G.p.loc] || [];
              if (conns.length) G.p.loc = conns[r(conns.length)];
              G.world.dgStage = 6;
              G.paused = false;
              startTimer();
              log('도망쳤다. 하지만 아직 학교 안이다.', 'na');
            } else {
              G.p.hp = clamp(G.p.hp - 20, 0, G.p.maxhp);
              if (G.p.hp <= 0) die('도망치다 쓰러졌다.');
              else {
                log('도망치다 잡혔다. HP -20', 'da');
                G.world.dgStage = 6;
                G.paused = false;
                startTimer();
              }
            }
          },
        });
        setTimeout(
          () =>
            showModal(
              '// 박대겸이 나타났다',
              '"오래 찾았어.\n재밌었어, 도망 다니는 거.\n\n근데 이제 끝낼게."',
              choices,
              true,
            ),
          1000,
        );
      }

      // ═══════════════════════════════════════
      // DG MESSAGES
      // ═══════════════════════════════════════
      const DGMSGS = [
        {
          msg: '"잘 자고 있어?\n나는 못 자.\n어차피 잘 필요가 없으니까."',
          choices: ['폰 끈다', '읽고 무시', '답장한다'],
        },
        {
          msg: '"오늘 네가 어디 있었는지 봤어.\n창문 쪽으론 가지 마."',
          choices: ['숨는다', '창문 확인', '경고 무시'],
        },
        {
          msg: '"교장 불쌍하지 않아?\n나는 그냥 물어봤을 뿐인데."',
          choices: ['전화 끈다', '침묵', '신고하려 한다'],
        },
        {
          msg: '"배고프지?\n나한테 오면 줄 수 있어."',
          choices: ['거절한다', '조건을 묻는다'],
        },
        {
          msg: '"몇 명이나 살아남을 것 같아?\n나는 한 명만 있으면 돼."',
          choices: ['읽고 무시', '공포에 떤다'],
        },
        {
          msg: '"넌 꽤 재밌어.\n그래서 아직 두고 있는 거야."',
          choices: ['폰 끈다', '무서워한다', '맞서겠다고 답'],
        },
      ];
      let dgTimerInt, dgCD;
      function triggerDgMsg() {
        const msgData = DGMSGS[r(DGMSGS.length)];
        document.getElementById('dgmsg').textContent = msgData.msg;
        dgCD = 20;
        document.getElementById('dgtimer').textContent = dgCD;
        const cb = document.getElementById('dgchoices');
        cb.innerHTML = '';
        msgData.choices.forEach((c, i) => {
          const btn = document.createElement('button');
          btn.className = 'pch';
          btn.textContent = `[${String.fromCharCode(65 + i)}] ${c}`;
          btn.onclick = () => respondDg(i, c);
          cb.appendChild(btn);
        });
        document.getElementById('dgphone').classList.add('active');
        G.paused = true;
        log('[박대겸] 문자 수신.', 'dg');
        dgTimerInt = setInterval(() => {
          dgCD--;
          document.getElementById('dgtimer').textContent = dgCD;
          if (dgCD <= 0) {
            clearInterval(dgTimerInt);
            document.getElementById('dgphone').classList.remove('active');
            G.paused = false;
            G.p.sanity = clamp(G.p.sanity - 15, 0, 100);
            G.p.hp = clamp(G.p.hp - 8, 0, G.p.maxhp);
            log('문자에 반응하지 못했다. 심리-15 HP-8', 'da');
            checkDeath();
            fullUpdate();
          }
        }, 1000);
      }
      function respondDg(idx, label) {
        clearInterval(dgTimerInt);
        document.getElementById('dgphone').classList.remove('active');
        G.paused = false;
        const resps = [
          () => {
            G.p.sanity = clamp(G.p.sanity - 4, 0, 100);
            log('폰을 껐다. 메시지가 계속 울렸다.', 'na');
          },
          () => {
            G.p.sanity = clamp(G.p.sanity - 8, 0, 100);
            log('읽고 무시했다. 심리-8', 'na');
          },
          () => {
            G.p.fatigue = clamp(G.p.fatigue + 15, 0, 100);
            gainXp('stealth', 5);
            log('숨을 곳을 찾아 숨었다. 피로+15', 'ok');
          },
          () => {
            G.p.money += 120;
            addItem('food_ration', 1);
            G.world.totalFood += 1;
            G.p.rep = clamp(G.p.rep - 15, 0, 100);
            G.p.sanity = clamp(G.p.sanity - 10, 0, 100);
            log('[대겸] 문 앞에 식량이 놓여 있었다. 평판-15', 'dgt');
          },
          () => {
            G.p.sanity = clamp(G.p.sanity - 10, 0, 100);
            log('공포에 떨었다. 무릎이 풀렸다.', 'da');
          },
          () => {
            G.p.sanity = clamp(G.p.sanity - 5, 0, 100);
            log('침묵했다. 적어도 반응하지는 않았다.', 'na');
          },
          () => {
            G.p.hp = clamp(G.p.hp - 5, 0, G.p.maxhp);
            G.p.sanity = clamp(G.p.sanity - 8, 0, 100);
            log('맞서겠다고 했다. 한동안 응답이 없었다. HP-5', 'na');
            gainXp('combat', 3);
          },
        ];
        resps[idx % resps.length]();
        G.p.sanity = clamp(G.p.sanity - 3, 0, 100);
        checkDeath();
        fullUpdate();
      }

      // ═══════════════════════════════════════
      // RANDOM EVENTS
      // ═══════════════════════════════════════
      const RAND_EVS = [
        () => {
          G.world.totalFood = Math.max(0, G.world.totalFood - 12);
          G.world.order = clamp(G.world.order - 6, 0, 100);
          log('[사건] 배급 줄에서 싸움. 식량 낭비.', 'da');
        },
        () => {
          const d = r(2) + 1;
          for (let i = 0; i < d; i++) {
            const v = G.people.filter(
              (p) => p.alive && p.id.startsWith('anon'),
            );
            if (v.length) {
              v[r(v.length)].alive = false;
              G.world.deaths++;
            }
          }
          log(`[부고] 익명 ${d}명 추가 사망.`, 'de');
          G.p.sanity = clamp(G.p.sanity - 4, 0, 100);
        },
        () => {
          const c = r(70) + 20;
          G.p.money += c;
          log(`[우연] 화장실에서 ${c}원 발견.`, 'ok');
        },
        () => {
          log('[경보] "구조대가 왔다!" — 거짓말이었다.', 'ev');
          G.world.order = clamp(G.world.order - 5, 0, 100);
          G.p.sanity = clamp(G.p.sanity - 7, 0, 100);
        },
        () => {
          const f = r(5) + 3;
          G.world.totalFood += f;
          log(`[발견] 창고에서 숨겨진 식량 ${f}개 발견.`, 'ok');
        },
        () => {
          if (rr() < 0.35 && !hasItem('lock')) {
            const s = Math.min(G.p.money, r(90) + 20);
            G.p.money -= s;
            log(`[도난] ${s}원 소매치기.`, 'da');
          }
        },
        () => {
          log('[분위기] 밤새 누군가 우는 소리. 아무도 확인하지 않았다.', 'ev');
          G.p.sanity = clamp(G.p.sanity - 5, 0, 100);
        },
        () => {
          addItem('water_bottle');
          log('[발견] 창문으로 받은 빗물.`', 'ok');
        },
        () => {
          G.world.order = clamp(G.world.order - 8, 0, 100);
          log('[폭력] 복도에서 집단 폭행. 아무도 말리지 않았다.', 'da');
          G.p.sanity = clamp(G.p.sanity - 6, 0, 100);
        },
        () => {
          const it = ['lighter', 'rope', 'notebook', 'phone'][r(4)];
          addItem(it);
          log(`[발견] ${ITEMS[it] ? ITEMS[it].name : it}을(를) 발견.`, 'ok');
        },
        () => {
          G.world.temp--;
          log(`[날씨] 기온 하락. 현재 ${G.world.temp}°C.`, 'da');
          if (!hasItem('warm_clothes'))
            G.p.hp = clamp(G.p.hp - 3, 0, G.p.maxhp);
        },
        () => {
          G.p.sanity = clamp(G.p.sanity + 8, 0, 100);
          log('[위로] 누군가 말없이 초콜릿 조각을 건넸다.', 'ok');
        },
        () => {
          addItem('antibiotics');
          log('[발견] 항생제가 바닥에 떨어져 있었다.', 'ok');
        },
        () => {
          const named = G.people.filter(
            (p) => p.alive && !p.id.startsWith('anon') && p.id !== 'daegyeom',
          );
          if (named.length) {
            const v = named[r(named.length)];
            v.hp = Math.max(0, v.hp - 15);
            if (v.hp <= 0) v.alive = false;
            log(
              `[부고] ${v.name}이(가) ${v.hp <= 0 ? '사망했다' : '부상을 입었다'}.`,
              'de',
            );
            G.p.sanity = clamp(G.p.sanity - 8, 0, 100);
          }
        },
        () => {
          G.p.rep = clamp(G.p.rep + 5, 0, 100);
          log('[소문] 좋은 평이 돌고 있다.', 'ok');
        },
        () => {
          G.p.rep = clamp(G.p.rep - 7, 0, 100);
          log('[소문] 나쁜 소문이 나돌고 있다. 평판-7', 'da');
        },
        () => {
          if (G.world.dgStage >= 2) {
            log('[대겸] 복도 끝에서 웃음소리. 혼자였다.', 'dg');
            G.p.sanity = clamp(G.p.sanity - 8, 0, 100);
          }
        },
        () => {
          const f = r(3) + 1;
          G.addItem('food_ration', f);
          G.world.totalFood += f;
          log(`[행운] 식량 ${f}개가 문 앞에 놓여 있었다.`, 'ok');
        },
        () => {
          G.p.sick = true;
          log('[이상] 갑자기 속이 좋지 않다. 아픈 것 같다.', 'da');
        },
        () => {
          log(
            '[자살 시도] 2층 창문에서 뛰어내리려는 학생을 누가 막았다.',
            'da',
          );
          G.world.order = clamp(G.world.order - 4, 0, 100);
          G.p.sanity = clamp(G.p.sanity - 10, 0, 100);
        },
        () => {
          G.world.order = clamp(G.world.order + 5, 0, 100);
          log('[학생회] 문하영이 학생들을 모아 질서를 잡으려 한다.', 'ev');
          const c = gp('council1');
          if (c) changeAff('council1', 5);
        },
        () => {
          G.p.fatigue = clamp(G.p.fatigue + 20, 0, 100);
          log('[소음] 밤새 소음으로 제대로 쉬지 못했다. 피로+20', 'da');
        },
        () => {
          const cash = r(200) + 50;
          G.p.money += cash;
          log(`[발견] 사물함 속 가방에서 ${cash}원 발견.`, 'ok');
        },
        () => {
          log('[무전] 라디오에서 희미한 신호. "...3일...구조..."', 'in');
          if (hasItem('radio')) gainXp('intel', 5);
        },
      ];

      function triggerRandEv() {
        RAND_EVS[r(RAND_EVS.length)]();
        checkDeath();
        fullUpdate();
      }

      // ═══════════════════════════════════════
      // SCHEDULED EVENTS
      // ═══════════════════════════════════════
      function checkScheduled() {
        const done = G.world.evsDone;
        const d = G.day;
        if (d === 2 && !done.includes('d2')) {
          done.push('d2');
          setTimeout(ev_day2, 1500);
        }
        if (d === 3 && !done.includes('d3')) {
          done.push('d3');
          setTimeout(ev_day3, 1500);
        }
        if (d === 4 && !done.includes('d4')) {
          done.push('d4');
          setTimeout(ev_day4, 1500);
        }
        if (d === 5 && !done.includes('d5')) {
          done.push('d5');
          setTimeout(ev_day5, 2000);
        }
        if (d === 6 && !done.includes('d6')) {
          done.push('d6');
          setTimeout(ev_day6, 2000);
        }
        if (d === 8 && !done.includes('d8')) {
          done.push('d8');
          setTimeout(ev_day8, 2000);
        }
      }

      function ev_day2() {
        showModal(
          '// 2일째 — 소문',
          '아침에 이상한 소문이 돌았다.\n"박대겸이 어젯밤 교장실 근처를 혼자 다녔대."',
          [
            {
              label: '무시한다',
              sub: '',
              action: () => log('무시하기로 했다.', 'sy'),
            },
            {
              label: '대겸을 조사한다',
              sub: '돈-20, 정보+',
              action: () => {
                if (G.p.money < 20) {
                  toast('돈 부족', 'err');
                  return;
                }
                G.p.money -= 20;
                learnInfo('daegyeom_past');
                gainXp('intel', 5);
              },
            },
            {
              label: '직접 찾아간다',
              sub: '위험, 정보+',
              action: () => {
                G.p.sanity = clamp(G.p.sanity - 10, 0, 100);
                G.p.hp = clamp(G.p.hp - 3, 0, G.p.maxhp);
                learnInfo('daegyeom_file');
                log('[대겸] 마주쳤다. 눈빛이 이상했다.', 'dg');
              },
            },
          ],
        );
      }

      function ev_day3() {
        showModal(
          '// 3일째 — 배급 통제',
          '교장이 방송을 했다.\n"일하지 않는 자는 먹지 않는다."',
          [
            {
              label: '경비 자원',
              sub: '식량+2, 피로+20',
              action: () => {
                G.p.fatigue = clamp(G.p.fatigue + 20, 0, 100);
                addItem('food_ration', 2);
                G.world.totalFood += 2;
                G.world.order = clamp(G.world.order + 5, 0, 100);
                log('경비 자원. 식량 2개 수령.', 'ok');
                gainXp('combat', 4);
              },
            },
            {
              label: '배급 줄에 선다',
              sub: '식량+1',
              action: () => {
                addItem('food_ration');
                G.world.totalFood++;
                log('배급 줄. 식량 1개 수령.', 'na');
              },
            },
            {
              label: '학생들 선동',
              sub: '성공 시 평판+15',
              action: () => {
                if (rr() < 0.45 + skillBonus('social', 0.1)) {
                  G.world.order = clamp(G.world.order - 8, 0, 100);
                  G.p.rep = clamp(G.p.rep + 15, 0, 100);
                  log('선동 성공. 평판+15', 'ok');
                  gainXp('social', 10);
                } else {
                  G.p.rep = clamp(G.p.rep - 8, 0, 100);
                  log('선동 실패. 고립됐다.', 'da');
                }
              },
            },
            {
              label: '몰래 훔친다',
              sub: '위험',
              action: () => {
                if (rr() < 0.5 + skillBonus('stealth', 0.1)) {
                  const f = r(3) + 2;
                  G.addItem('food_ration', f);
                  G.world.totalFood += f;
                  G.p.rep = clamp(G.p.rep - 8, 0, 100);
                  log(`절도 성공. 식량 ${f}개. 평판-8`, 'ok');
                  gainXp('stealth', 8);
                } else {
                  G.p.rep = clamp(G.p.rep - 18, 0, 100);
                  G.p.hp = clamp(G.p.hp - 8, 0, G.p.maxhp);
                  log('절도 실패. 평판-18 HP-8', 'da');
                }
              },
            },
          ],
        );
      }

      function ev_day4() {
        showModal(
          '// 4일째 — 첫 문자',
          '밤에 알 수 없는 번호에서 문자가 왔다.\n"안녕. 잘 지내고 있어?"',
          [
            {
              label: '무시한다',
              sub: '심리-5',
              action: () => {
                G.p.sanity = clamp(G.p.sanity - 5, 0, 100);
                log('무시했지만 머릿속에서 지워지지 않는다.', 'na');
              },
            },
            {
              label: '"누구야?"',
              sub: '심리-10, 정보+',
              action: () => {
                G.p.sanity = clamp(G.p.sanity - 10, 0, 100);
                log('[?]: "몰라도 돼. 근데 넌 아직 살아있구나."', 'dgt');
                learnInfo('daegyeom_location');
              },
            },
            {
              label: '번호 추적 시도',
              sub: '돈-50, 정보+',
              action: () => {
                if (G.p.money < 50) {
                  toast('돈 부족', 'err');
                  return;
                }
                G.p.money -= 50;
                log('학교 내부 번호로 확인됐다. 발신자 미상.', 'in');
                gainXp('intel', 8);
              },
            },
          ],
          true,
        );
      }

      function ev_day5() {
        showModal(
          '// 5일째 — 세력 충돌',
          '급식실 앞에서 큰 충돌이 벌어졌다.\n불량배와 학생회가 맞붙었다.',
          [
            {
              label: '중재한다',
              sub: '평판 45 이상 필요',
              action: () => {
                if (G.p.rep < 45) {
                  toast('평판 부족', 'err');
                  return;
                }
                G.world.order = clamp(G.world.order + 8, 0, 100);
                G.p.rep = clamp(G.p.rep + 12, 0, 100);
                log('중재 성공. 치안+8 평판+12', 'ok');
                gainXp('social', 12);
              },
            },
            {
              label: '혼란 틈에 식량 챙김',
              sub: '위험',
              action: () => {
                const f = r(3) + 2;
                G.addItem('food_ration', f);
                G.world.totalFood += f;
                G.p.rep = clamp(G.p.rep - 10, 0, 100);
                G.p.sanity = clamp(G.p.sanity - 5, 0, 100);
                log(`식량 ${f}개 획득. 평판-10`, 'na');
              },
            },
            {
              label: '도망친다',
              sub: '',
              action: () => {
                G.p.fatigue = clamp(G.p.fatigue + 10, 0, 100);
                log('도망쳤다.', 'sy');
              },
            },
            {
              label: '한 쪽을 돕는다',
              sub: '세력 관계 변화, HP 손실',
              action: () => {
                G.p.hp = clamp(G.p.hp - 12, 0, G.p.maxhp);
                G.p.rep = clamp(G.p.rep - 5, 0, 100);
                log('싸움에 끼어들었다. HP-12', 'da');
                if (!G.p.ganged) {
                  G.p.ganged = true;
                  G.p.gangName = '불량배 무리';
                }
                gainXp('combat', 8);
              },
            },
          ],
        );
      }

      function ev_day6() {
        showModal(
          '// 6일째 — 모든 것을 안다',
          '이제 모두가 알고 있다.\n박대겸이 한 짓이라는 걸.\n\n하지만 아무도 움직이지 않는다.',
          [
            {
              label: '대겸을 막으려 한다',
              sub: '동맹 필요. 매우 위험',
              action: () => {
                G.p.sanity = clamp(G.p.sanity - 10, 0, 100);
                if (G.p.ganged) {
                  log(`${G.p.gangName}에 이야기했다. 미지근한 반응.`, 'in');
                } else log('혼자서는 어렵다.', 'da');
              },
            },
            {
              label: '숨는다',
              sub: '안전 우선',
              action: () => {
                G.p.fatigue = clamp(G.p.fatigue + 15, 0, 100);
                log('창고 깊숙이 숨었다.', 'na');
              },
            },
            {
              label: '대겸에게 접촉한다',
              sub: '극위험. 아이템 획득 가능',
              action: () => {
                G.p.sanity = clamp(G.p.sanity - 18, 0, 100);
                G.p.hp = clamp(G.p.hp - 5, 0, G.p.maxhp);
                if (rr() < 0.45) {
                  addItem('daegyeom_note');
                  log('대겸이 메모를 건넸다. "이거 갖고 싶어?"', 'dg');
                } else log('대겸이 웃었다. 그 웃음이 오래 남는다.', 'dg');
              },
            },
            {
              label: '아무것도 하지 않는다',
              sub: '심리-8',
              action: () => {
                G.p.sanity = clamp(G.p.sanity - 8, 0, 100);
                log('아무것도 하지 못했다.', 'na');
              },
            },
          ],
          true,
        );
      }

      function ev_day8() {
        showModal(
          '// 8일째 — 마지막 선택',
          '학교 밖에서 신호가 들렸다.\n군부대가 접근 중이다.\n\n대겸도 알고 있는 것 같다.',
          [
            {
              label: '신호에 응답한다 (라디오)',
              sub: hasItem('radio') ? '라디오 있음' : '라디오 없으면 어렵다',
              action: () => {
                if (!hasItem('radio')) {
                  toast('라디오 없음', 'err');
                  return;
                }
                gainXp('intel', 15);
                log('[라디오] 신호 발신 성공. 구조대가 위치를 확인했다.', 'ok');
                G.p.sanity = clamp(G.p.sanity + 15, 0, 100);
              },
            },
            {
              label: '생존자들을 모아 조직화한다',
              sub: '평판 50+, 세력 필요',
              action: () => {
                if (G.p.rep < 50 || !G.p.ganged) {
                  toast('조건 미충족', 'err');
                  return;
                }
                G.world.order = clamp(G.world.order + 15, 0, 100);
                G.p.rep = clamp(G.p.rep + 12, 0, 100);
                log('생존자들을 모아 구조를 준비했다.', 'ok');
              },
            },
            {
              label: '대겸을 먼저 처리한다',
              sub: '최종 대결로 진입',
              action: () => {
                finalConfront();
              },
            },
          ],
        );
      }

      // ═══════════════════════════════════════
      // ENDINGS
      // ═══════════════════════════════════════
      function checkEnding() {
        if (G.over) return;
        const p = G.p;
        const w = G.world;
        const alive = G.people.filter((x) => x.alive).length;

        // 1. STARVATION (Immediate)
        if (
          w.totalFood <= 0 &&
          G.day > 1 &&
          !hasItem('food_ration') &&
          !hasItem('canned_food')
        ) {
          showEnding('starve');
          return;
        }
        // 2. SLAUGHTER
        if (p.killCount >= 5) {
          showEnding('slaughter');
          return;
        }
        // 3. EXPOSURE (Phone + Note + Rooftop)
        if (
          p.loc === 'rooftop' &&
          hasItem('daegyeom_note') &&
          w.dgStage >= 3 &&
          hasItem('phone')
        ) {
          showEnding('exposure');
          return;
        }
        // 4. VILLAIN'S SIDE
        const dg = gp('daegyeom');
        if (dg && dg.affinity >= 30 && w.dgStage >= 3) {
          showEnding('villain');
          return;
        }
        // 5. ESCAPE (Secret Tunnel + Rope + Warehouse)
        if (
          p.loc === 'warehouse' &&
          hasItem('secret_tunnel_note') &&
          hasItem('rope')
        ) {
          showEnding('escape_warehouse');
          return;
        }
        // 6. HERO
        if (
          w.order >= 70 &&
          p.rep >= 80 &&
          w.factions.gangsters.friendly &&
          w.factions.honor.friendly
        ) {
          showEnding('hero');
          return;
        }
        // 7. RESCUE (Day 9 Survived)
        if (G.day >= 9 && w.order >= 40) {
          showEnding('rescue');
          return;
        }
      }

      function showEnding(type) {
        G.over = true;
        clearInterval(G.timer);
        const ENDS = {
          starve: {
            pre: 'DAY ' + G.day + ' · 아사',
            title: '종말',
            sub: '식량이 바닥났다',
            desc: `학교의 모든 식량이 사라졌다.\n\n더 이상 누굴 믿을 수도, 누굴 해칠 힘도 없다.\n\n어둠 속에서 넌 서서히 의식을 잃어갔다.`,
            cls: 'death',
          },
          slaughter: {
            pre: 'DAY ' + G.day + ' · 학살자',
            title: '살인귀',
            sub: '피로 물든 손',
            desc: `구조대가 왔을 때, 그들이 본 것은 지옥이었다.\n\n생존자보다 시체가 더 많았다.\n넌 살아남았지만, 사람들은 너를 두려워하며 멀리했다.`,
            cls: 'death',
          },
          exposure: {
            pre: 'DAY ' + G.day + ' · 폭로',
            title: '진실',
            sub: '세상에 알렸다',
            desc: `옥상에서 신호를 보냈다.\n대겸의 일기장과 핸드폰... 진실이 세상에 공개됐다.\n\n헬기가 학교 상공을 뒤덮었다.\n넌 이 지옥의 목격자가 되었다.`,
            cls: 'win',
          },
          villain: {
            pre: 'DAY ' + G.day + ' · 동조',
            title: '공범',
            sub: '대겸의 오른팔',
            desc: `대겸의 눈에서 증오 대신 동질감을 보았다.\n\n넌 그의 규칙을 집행하는 자가 되었다.\n학교는 이제 너희들의 왕국이다.\n구조대는 결코 오지 않을 것이다.`,
            cls: 'death',
          },
          escape_warehouse: {
            pre: 'DAY ' + G.day + ' · 탈출',
            title: '생존',
            sub: '비밀 통로',
            desc: `창고 구석의 낡은 바닥을 뜯어냈다.\n지하로 연결된 비밀 통로... 밧줄을 타고 내려갔다.\n\n학교 담장 밖, 차가운 공기가 폐를 찌른다.\n살았다.`,
            cls: 'win',
          },
          hero: {
            pre: 'DAY ' + G.day + ' · 영웅',
            title: '진정한 리더',
            sub: '모두를 구했다',
            desc: `질서를 유지하고 사람들을 단결시켰다.\n\n대겸조차 너의 기세 앞에 무릎을 꿇었다.\n구조대가 문을 열었을 때, 넌 모두를 이끌고 걸어나왔다.\n역사는 너를 기억할 것이다.`,
            cls: 'win',
          },
          rescue: {
            pre: 'DAY ' + G.day + ' · 생존',
            title: '구조',
            sub: '버텼다',
            desc: `기다림의 끝에 사이렌 소리가 들렸다.\n\n지옥 같던 날들이 끝났다.\n넌 살아남았고, 학교 밖으로 한 걸음을 내디뎠다.`,
            cls: 'win',
          },
          fight: {
            pre: 'DAY ' + G.day + ' · 승리',
            title: '생존',
            sub: '최후의 승자',
            desc: `상처를 입었지만 대겸을 제압했다.\n\n학교에 정적이 찾아왔다.\n구조대가 들어왔을 때, 넌 아직 서 있었다.`,
            cls: 'win',
          },
        };
        const e = ENDS[type] || ENDS.fight;
        setTimeout(() => {
          const box = document.getElementById('obox');
          box.className = 'obox ' + (e.cls || 'win');
          box.innerHTML = `<div class="opre">${e.pre}</div><div class="otitle ${e.cls}">${e.title}</div><div class="osub">${e.sub}</div><div class="odesc">${e.desc}\n\n생존자: ${G.people.filter((p) => p.alive).length}명\nDAY ${G.day} 생존</div><div class="obbg"><button class="obtn" onclick="location.reload()">[ 다시 시작 ]</button></div>`;
          document.getElementById('overlay').classList.remove('h');
        }, 1200);
      }

      function die(reason) {
        G.over = true;
        clearInterval(G.timer);
        setTimeout(() => {
          const box = document.getElementById('obox');
          box.className = 'obox dead';
          box.innerHTML = `<div class="opre">DAY ${G.day} · 사망</div><div class="otitle dead">사망</div><div class="osub">${reason}</div><div class="odesc">HP: 0\n생존자: ${G.people.filter((p) => p.alive).length}명\n\n아무도 눈치채지 못했다.\n복도는 여전히 조용했다.</div><div class="obbg"><button class="obtn" onclick="location.reload()">[ 다시 시작 ]</button></div>`;
          document.getElementById('overlay').classList.remove('h');
        }, 800);
      }

      function checkDeath() {
        const p = G.p;
        if (p.hp <= 0) die('체력이 바닥났다.');
        else if (p.hunger >= 100) die('굶어 죽었다.');
        else if (p.thirst >= 100) die('탈수로 쓰러졌다.');
        else if (p.sanity <= 0) die('정신이 무너졌다. 더 이상 버틸 수 없었다.');
        else if (G.people.filter((p) => p.alive).length <= 0)
          die('모든 생존자가 사망했다.');
      }

      // ═══════════════════════════════════════
      // INPUT
      // ═══════════════════════════════════════
      function setupInput() {
        const inp = document.getElementById('cmdinput');
        inp.addEventListener('keydown', (e) => {
          if (e.key !== 'Enter') return;
          const cmd = inp.value.trim().toLowerCase();
          inp.value = '';
          handleCmd(cmd);
        });
        inp.focus();
        document.addEventListener('keydown', (e) => {
          if (
            document.getElementById('modalbg').classList.contains('h') === false
          )
            return;
          if (document.getElementById('dgphone').classList.contains('active'))
            return;
          if (e.target === inp) return;
          const map = {
            e: 'eat',
            w: 'drink',
            r: 'rest',
            m: 'medic',
            f: 'explore',
            v: 'move',
            o: 'scout',
            t: 'talk',
            b: 'trade',
            g: 'guard',
            h: 'help',
            i: 'intel',
            x: 'rob',
            n: 'gang',
            c: 'craft',
            q: 'charskill',
            z: 'hide',
          };
          if (map[e.key]) {
            e.preventDefault();
            doAction(map[e.key]);
          }
          const tabs = {
            1: 'world',
            2: 'action',
            3: 'people',
            4: 'map',
            5: 'skill',
          };
          if (tabs[e.key]) {
            const tab = document.querySelector(`.tab:nth-child(${e.key})`);
            if (tab) tab.click();
          }
          // Save/Load shortcuts
          if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            saveGame();
          }
          if (e.ctrlKey && e.key === 'l') {
            e.preventDefault();
            loadGame();
          }
        });
      }

      function handleCmd(cmd) {
        const aliases = {
          먹: 'eat',
          식사: 'eat',
          먹다: 'eat',
          물: 'drink',
          마시다: 'drink',
          쉬다: 'rest',
          휴식: 'rest',
          치료: 'medic',
          약: 'medic',
          탐색: 'explore',
          뒤지다: 'explore',
          이동: 'move',
          지도: 'move',
          정찰: 'scout',
          대화: 'talk',
          말: 'talk',
          거래: 'trade',
          교환: 'trade',
          경계: 'guard',
          돕다: 'help',
          도움: 'help',
          정보: 'intel',
          인텔: 'intel',
          약탈: 'rob',
          협박: 'rob',
          세력: 'gang',
          제작: 'craft',
          만들다: 'craft',
          특수: 'charskill',
          '?': 'help_cmd',
          도움말: 'help_cmd',
          help: 'help_cmd',
          status: 'status',
          상태: 'status',
          save: 'save',
          저장: 'save',
          load: 'load',
          불러오기: 'load',
          delsave: 'delsave',
        };
        const a = aliases[cmd] || cmd;
        if (a === 'save') {
          saveGame();
          return;
        }
        if (a === 'load') {
          loadGame();
          return;
        }
        if (a === 'delsave') {
          deleteSave();
          return;
        }
        if (a === 'help_cmd') {
          log('[ 명령어 ]', 'in');
          log('e=식사 w=물 r=휴식 m=치료 f=탐색 v=이동(지도) o=정찰', 'sy');
          log(
            't=대화 b=거래 g=경계 h=돕기 i=정보 x=약탈 n=세력 c=제작 q=특수',
            'sy',
          );
          log('숫자 1-5: 탭 전환 | 지도탭에서 방 클릭으로 이동', 'sy');
          log('save=저장 | load=불러오기 | Ctrl+S/L 단축키', 'sy');
          return;
        }
        if (a === 'status') {
          const p = G.p;
          log(`[ ${p.name} · ${p.charClass} · DAY${G.day} ]`, 'in');
          log(
            `HP:${p.hp} 배고픔:${p.hunger} 갈증:${p.thirst} 피로:${p.fatigue} 심리:${p.sanity}`,
            'in',
          );
          log(
            `식량:${itemQty('food_ration')} 물:${itemQty('water_bottle')} 돈:${p.money} 평판:${p.rep} SP:${p.sp}`,
            'in',
          );
          const skList = Object.entries(p.skills)
            .filter(([, v]) => v > 0)
            .map(([k, v]) => `${k}:${v}`)
            .join(' ');
          if (skList) log(`스킬: ${skList}`, 'in');
          if (p.ganged) log(`세력: ${p.gangName}`, 'in');
          return;
        }
        const actions = [
          'eat',
          'drink',
          'rest',
          'medic',
          'explore',
          'move',
          'scout',
          'talk',
          'trade',
          'guard',
          'help',
          'intel',
          'rob',
          'gang',
          'craft',
          'charskill',
        ];
        if (actions.includes(a)) {
          doAction(a);
          return;
        }
        log(`> "${cmd}" — 모름. ?=도움말`, 'sy');
      }

      // ═══════════════════════════════════════
      // TITLE / CHAR SELECT
      // ═══════════════════════════════════════
      function showTitle() {
        const box = document.getElementById('obox');
        box.className = 'obox';
        box.innerHTML = `<div class="opre">재난 발생 9일째</div><div class="otitle" style="color:var(--t2)">CENTENNIAL</div><div class="osub">센테니얼 학교에서 살아남기</div><div class="odesc" id="titleDesc"></div><div class="obbg">${hasSave() ? '<button class="obtn" onclick="loadGame()" style="margin-bottom:6px;border-color:var(--okt);color:var(--okt)">[ 이어하기 ]</button>' : ''}<button class="obtn" onclick="showCharSelect()">[ 새 게임 ]</button></div>`;
        document.getElementById('overlay').classList.remove('h');
        // Typing effect for description
        const desc =
          '학교는 봉쇄됐다.\n100명의 학생들이 식량을 나눠 먹으며 버티고 있다.\n\n하지만 식량은 줄고 있다.\n그리고 누군가가 이 모든 걸 계획했다.\n\n넌 살아남을 수 있겠어?';
        const descEl = document.getElementById('titleDesc');
        let i = 0;
        function typeChar() {
          if (i < desc.length) {
            descEl.textContent += desc[i];
            i++;
            setTimeout(typeChar, desc[i - 1] === '\n' ? 120 : 30);
          }
        }
        typeChar();
      }

      function showCharSelect() {
        const box = document.getElementById('obox');
        box.innerHTML = `<div class="opre">캐릭터 선택</div><div class="otitle" style="font-size:18px;margin-bottom:10px;color:var(--t2)">어떤 사람이야?</div>
  
  <div class="cgrid">
      <div class="ccard" onclick="startGame('excley')">
        <div class="cname">미스 엑슬리 <span class="crole">교사</span></div>
        <div class="cdesc">깐깐한 교사. 권위와 지력.</div>
        <div class="cstats"><div class="cst">HP <span>75</span></div><div class="cst high">SP <span>2</span></div></div>
      </div>
  
      <div class="ccard" onclick="startGame('junkyu')">
        <div class="cname">우준규 <span class="crole">학생</span></div>
        <div class="cdesc">과학 영재. 아이템 제작 특화.</div>
        <div class="cstats"><div class="cst">HP <span>80</span></div><div class="cst">지력 <span>UP</span></div></div>
      </div>
  
      <div class="ccard" onclick="startGame('sebastian')">
        <div class="cname">세바스찬 <span class="crole">외부인</span></div>
        <div class="cdesc">수호자. 순찰과 전투 특화.</div>
        <div class="cstats"><div class="cst high">HP <span>120</span></div><div class="cst">무기 보유</div></div>
      </div>
  
      <div class="ccard" onclick="startGame('shinwon')">
        <div class="cname">박신원 <span class="crole">학생</span></div>
        <div class="cdesc">체력왕. 탐색과 속도 특화.</div>
        <div class="cstats"><div class="cst high">HP <span>150</span></div><div class="cst">식량 5개</div></div>
      </div>
  
      <div class="ccard" onclick="startGame('moongaleb')">
        <div class="cname">문갈랩 <span class="crole">학생</span></div>
        <div class="cdesc">프로듀서. 사교와 정신력 케어.</div>
        <div class="cstats"><div class="cst">HP <span>85</span></div><div class="cst high">사교++</div></div>
      </div>
  
      <div class="ccard" onclick="startGame('mincheol')">
        <div class="cname">김민철 <span class="crole">학생</span></div>
        <div class="cdesc">트레이딩 귀재. 가격 간파.</div>
        <div class="cstats"><div class="cst">HP <span>80</span></div><div class="cst high">돈++</div></div>
      </div>
  
      <div class="ccard" onclick="startGame('taichi')">
        <div class="cname">타이치 <span class="crole">유학생</span></div>
        <div class="cdesc">무술 라이벌. 압도적 투지.</div>
        <div class="cstats"><div class="cst high">HP <span>160</span></div><div class="cst high">전투력+</div></div>
      </div>
  
      <div class="ccard" onclick="startGame('yejun')">
        <div class="cname">김예준 <span class="crole">학생</span></div>
        <div class="cdesc">도박사. 확률의 지배자.</div>
        <div class="cstats"><div class="cst low">HP <span>70</span></div><div class="cst">운 <span>MAX</span></div></div>
      </div>
  
      <div class="ccard" onclick="startGame('heejae')">
        <div class="cname">신희재 <span class="crole">학생</span></div>
        <div class="cdesc">카사노바. 매혹과 선물.</div>
        <div class="cstats"><div class="cst">HP <span>90</span></div><div class="cst high">사교+</div></div>
      </div>

      <div class="ccard" onclick="startGame('tiffany')">
        <div class="cname">티파니 <span class="crole">학생</span></div>
        <div class="cdesc">퀸카. 매혹적인 유혹.</div>
        <div class="cstats"><div class="cst">HP <span>85</span></div><div class="cst high">사교++</div></div>
      </div>

      <div class="ccard" onclick="startGame('naip')">
        <div class="cname">나입 <span class="crole">중간상인</span></div>
        <div class="cdesc">만물상. 희귀 물품 조달.</div>
        <div class="cstats"><div class="cst">HP <span>90</span></div><div class="cst high">희귀템</div></div>
      </div>

      <div class="ccard" onclick="startGame('rednic')">
        <div class="cname">레드닉 <span class="crole">학생</span></div>
        <div class="cdesc">도둑. 소매치기와 리셀.</div>
        <div class="cstats"><div class="cst">HP <span>80</span></div><div class="cst high">은신++</div></div>
      </div>

      <div class="ccard" onclick="startGame('rako')">
        <div class="cname">라코 <span class="crole">유학생</span></div>
        <div class="cdesc">일본 부호. 막대한 자금력.</div>
        <div class="cstats"><div class="cst high">HP <span>100</span></div><div class="cst high">돈 5000</div></div>
      </div>

      <div class="ccard" onclick="startGame('jerry')">
        <div class="cname">제리 <span class="crole">유학생</span></div>
        <div class="cdesc">중국 부호. 라코의 연인.</div>
        <div class="cstats"><div class="cst">HP <span>95</span></div><div class="cst high">돈 4500</div></div>
      </div>

      <div class="ccard" onclick="startGame('cat')">
        <div class="cname">고양이 <span class="crole">동물</span></div>
        <div class="cdesc">과학실 고양이. 쥐 포획.</div>
        <div class="cstats"><div class="cst low">HP <span>40</span></div><div class="cst high">회피 MAX</div></div>
      </div>
  </div>`;
      }

      function startGame(cls) {
        document.getElementById('overlay').classList.add('h');
        G.people = makePeople();
        const configs = {
          excley: {
            name: '미스 엑슬리',
            hp: 75,
            maxhp: 75,
            money: 900,
            rep: 60,
            sp: 2,
            skills: {
              strength: 0,
              agility: 0,
              social: 1,
              intel: 2,
              survival: 0,
              stealth: 0,
              medical: 1,
              combat: 0,
            },
            xp: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 0,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            startItems: [
              'food_ration',
              'food_ration',
              'water_bottle',
              'water_bottle',
            ],
            startLoc: 'office',
          },
          junkyu: {
            name: '우준규',
            hp: 80,
            maxhp: 80,
            money: 600,
            rep: 45,
            sp: 1,
            skills: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 2,
              survival: 1,
              stealth: 0,
              medical: 1,
              combat: 0,
            },
            xp: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 0,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            startItems: [
              'chemicals',
              'lighter',
              'food_ration',
              'food_ration',
              'water_bottle',
            ],
            startLoc: 'science_lab',
          },
          sebastian: {
            name: '세바스찬',
            hp: 120,
            maxhp: 120,
            money: 800,
            rep: 35,
            sp: 1,
            skills: {
              strength: 2,
              agility: 1,
              social: 0,
              intel: 0,
              survival: 1,
              stealth: 0,
              medical: 0,
              combat: 2,
            },
            xp: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 0,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            startItems: ['pipe', 'food_ration', 'water_bottle', 'water_bottle'],
            startLoc: 'hallway1',
            weapon: 'pipe',
          },
          shinwon: {
            name: '박신원',
            hp: 150,
            maxhp: 150,
            money: 300,
            rep: 40,
            sp: 1,
            skills: {
              strength: 2,
              agility: 2,
              social: 0,
              intel: 0,
              survival: 1,
              stealth: 0,
              medical: 0,
              combat: 1,
            },
            xp: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 0,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            startItems: [
              'food_ration',
              'food_ration',
              'food_ration',
              'food_ration',
              'food_ration',
              'water_bottle',
              'water_bottle',
              'water_bottle',
            ],
            startLoc: 'classroom_a',
          },
          moongaleb: {
            name: '문갈랩',
            hp: 85,
            maxhp: 85,
            money: 450,
            rep: 50,
            sp: 2,
            skills: {
              strength: 0,
              agility: 0,
              social: 2,
              intel: 1,
              survival: 0,
              stealth: 1,
              medical: 0,
              combat: 0,
            },
            xp: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 0,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            startItems: ['food_ration', 'food_ration', 'water_bottle'],
            startLoc: 'classroom_b',
          },
          mincheol: {
            name: '김민철',
            hp: 80,
            maxhp: 80,
            money: 1200,
            rep: 40,
            sp: 1,
            skills: {
              strength: 0,
              agility: 0,
              social: 2,
              intel: 2,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            xp: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 0,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            startItems: ['food_ration', 'water_bottle'],
            startLoc: 'office',
          },
          taichi: {
            name: '타이치',
            hp: 160,
            maxhp: 160,
            money: 200,
            rep: 30,
            sp: 1,
            skills: {
              strength: 2,
              agility: 1,
              social: 0,
              intel: 0,
              survival: 1,
              stealth: 0,
              medical: 0,
              combat: 2,
            },
            xp: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 0,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            startItems: ['food_ration', 'food_ration', 'water_bottle'],
            startLoc: 'gym',
            weapon: 'pipe',
          },
          yejun: {
            name: '김예준',
            hp: 70,
            maxhp: 70,
            money: 500,
            rep: 20,
            sp: 2,
            skills: {
              strength: 0,
              agility: 1,
              social: 1,
              intel: 2,
              survival: 0,
              stealth: 1,
              medical: 0,
              combat: 0,
            },
            xp: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 0,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            startItems: ['food_ration', 'water_bottle'],
            startLoc: 'classroom_c',
          },
          heejae: {
            name: '신희재',
            hp: 90,
            maxhp: 90,
            money: 700,
            rep: 55,
            sp: 2,
            skills: {
              strength: 0,
              agility: 0,
              social: 3,
              intel: 1,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            xp: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 0,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            startItems: ['food_ration', 'food_ration', 'water_bottle'],
            startLoc: 'health_room',
          },
          tiffany: {
            name: '티파니',
            hp: 85,
            maxhp: 85,
            money: 1200,
            rep: 40,
            sp: 2,
            skills: {
              strength: 0,
              agility: 1,
              social: 3,
              intel: 1,
              survival: 0,
              stealth: 1,
              medical: 0,
              combat: 0,
            },
            xp: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 0,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            startItems: ['food_ration', 'water_bottle'],
            startLoc: 'rooftop',
          },
          naip: {
            name: '나입',
            hp: 90,
            maxhp: 90,
            money: 3000,
            rep: 50,
            sp: 1,
            skills: {
              strength: 1,
              agility: 1,
              social: 2,
              intel: 2,
              survival: 2,
              stealth: 1,
              medical: 0,
              combat: 1,
            },
            xp: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 0,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            startItems: ['radio', 'gas_mask', 'canned_food'],
            startLoc: 'hallway1',
          },
          rednic: {
            name: '레드닉',
            hp: 80,
            maxhp: 80,
            money: 500,
            rep: 10,
            sp: 2,
            skills: {
              strength: 0,
              agility: 2,
              social: 0,
              intel: 1,
              survival: 1,
              stealth: 3,
              medical: 0,
              combat: 1,
            },
            xp: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 0,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            startItems: ['knife', 'lighter'],
            startLoc: 'warehouse',
          },
          rako: {
            name: '라코',
            hp: 100,
            maxhp: 100,
            money: 5000,
            rep: 30,
            sp: 1,
            skills: {
              strength: 1,
              agility: 1,
              social: 2,
              intel: 2,
              survival: 1,
              stealth: 0,
              medical: 0,
              combat: 1,
            },
            xp: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 0,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            startItems: ['canned_food', 'canned_food', 'water_bottle'],
            startLoc: 'office',
          },
          jerry: {
            name: '제리',
            hp: 95,
            maxhp: 95,
            money: 4500,
            rep: 35,
            sp: 1,
            skills: {
              strength: 0,
              agility: 1,
              social: 3,
              intel: 1,
              survival: 1,
              stealth: 0,
              medical: 1,
              combat: 0,
            },
            xp: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 0,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            startItems: ['canned_food', 'canned_food', 'water_bottle'],
            startLoc: 'office',
          },
          cat: {
            name: '고양이',
            hp: 40,
            maxhp: 40,
            money: 0,
            rep: 0,
            sp: 0,
            skills: {
              strength: 0,
              agility: 5,
              social: 0,
              intel: 0,
              survival: 3,
              stealth: 4,
              medical: 0,
              combat: 1,
            },
            xp: {
              strength: 0,
              agility: 0,
              social: 0,
              intel: 0,
              survival: 0,
              stealth: 0,
              medical: 0,
              combat: 0,
            },
            startItems: [],
            startLoc: 'science_lab',
          },
        };
        const c = configs[cls];
        Object.assign(G.p, { charClass: cls, ...c });
        c.startItems.forEach((i) => addItem(i));
        document.getElementById('charname').textContent = G.p.name;
        document.getElementById('charname').style.display = 'block';
        // Setup action buttons
        document.querySelectorAll('.abtn[data-a]').forEach((btn) => {
          btn.addEventListener('click', () => doAction(btn.dataset.a));
        });
        logGap();
        logSep('아침');
        log('재난 발생 9일째. 센테니얼 고등학교.', 'in');
        log('100명의 생존자. 식량 800개. 시간은 줄고 있다.', 'sy');
        log(`${G.p.name} — 살아남아야 한다.`, 'ev');
        if (cls === 'excley')
          log('[교사 권위] 학생들을 명령하는 특수 능력을 갖고 있다. [Q]', 'ok');
        if (cls === 'junkyu')
          log(
            '[과학 실험] 화학약품으로 특수 아이템을 합성할 수 있다. [Q]',
            'ok',
          );
        if (cls === 'sebastian')
          log('[가디언] 순찰과 전투 특수 능력이 있다. [Q]', 'ok');
        if (cls === 'shinwon')
          log('[체력왕] 극한 탐색과 질주 능력이 있다. [Q]', 'ok');
        if (cls === 'moongaleb')
          log('[비트 드랍] 주변의 멘탈을 관리하고 매력을 발산한다. [Q]', 'ok');
        if (cls === 'mincheol')
          log(
            '[시장 간파] 아이템의 가치를 꿰뚫고 유리한 거래를 유도한다. [Q]',
            'ok',
          );
        if (cls === 'taichi')
          log('[카나소바 투지] 전투에서 죽지 않는 투지를 보여준다. [Q]', 'ok');
        if (cls === 'yejun')
          log('[올인] 모든 것을 건 도박을 시작한다. 결과는 운이다. [Q]', 'ok');
        if (cls === 'heejae')
          log(
            '[매혹의 눈빛] 주변 인물들을 매료시켜 협조를 이끌어낸다. [Q]',
            'ok',
          );

        log('탭을 눌러 현황/행동/인물/지도/스킬을 확인하라.', 'sy');
        log('?=도움말 | 숫자키 1-5: 탭 전환', 'sy');
        logGap();
        setupInput();
        fullUpdate();
        startTimer();

        // Trigger Tutorial if first game (simple check: no save or new session)
        if (!hasSave()) {
          setTimeout(showTutorial, 1500);
        }
      }

      function showTutorial() {
        const steps = [
          {
            t: '생존의 기본',
            b: '이곳 센테니얼은 봉쇄되었습니다. 식량과 물은 유한하며, 시간이 지날수록 전 세계적인 기근이 찾아옵니다. 배고픔과 갈증 수치를 잘 관리하십시오.',
          },
          {
            t: '거래와 인맥',
            b: '혼자서는 살아남을 수 없습니다. [B] 키를 눌러 주변 학생들과 거래하십시오. 평판이 높을수록 좋은 가격에 물건을 구할 수 있습니다.',
          },
          {
            t: '은신과 위험',
            b: '[Z] 키를 눌러 숨을 수 있습니다. 박대겸이 나타나거나 학생들이 싸움을 벌일 때 숨어있는 것이 안전합니다. 방마다 숨을 곳과 들킬 확률이 다릅니다.',
          },
          {
            t: '진실을 향해',
            b: '대화를 통해 정보를 수집하고, 창고 지하의 비밀을 밝혀내십시오. 당신의 선택에 따라 8가지의 서로 다른 소말이 기다리고 있습니다.',
          },
        ];

        let cur = 0;
        function next() {
          if (cur >= steps.length) {
            closeModal();
            log('⚠️ 튜토리얼 완료. 행운을 빈다.', 'ok');
            return;
          }
          const s = steps[cur];
          showModal(s.t, s.b, [
            {
              label: '다음',
              action: () => {
                cur++;
                next();
              },
            },
          ]);
        }
        next();
      }
      // ═══════════════════════════════════════
      // SAVE / LOAD SYSTEM
      // ═══════════════════════════════════════
      const SAVE_KEY = 'centennial_save';
      function saveGame() {
        try {
          const saveData = {
            day: G.day,
            time: G.time,
            dayLen: G.dayLen,
            phase: G.phase,
            over: G.over,
            p: JSON.parse(JSON.stringify(G.p)),
            world: JSON.parse(JSON.stringify(G.world)),
            people: JSON.parse(JSON.stringify(G.people)),
            version: 2,
          };
          localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
          toast('게임 저장됨', 'win');
          log('[시스템] 게임이 저장되었습니다.', 'sy');
        } catch (e) {
          toast('저장 실패', 'err');
        }
      }
      function loadGame() {
        try {
          const raw = localStorage.getItem(SAVE_KEY);
          if (!raw) {
            toast('저장된 게임 없음', 'err');
            return false;
          }
          const d = JSON.parse(raw);
          if (!d.version || d.version < 2) {
            toast('호환되지 않는 세이브', 'err');
            return false;
          }
          G.day = d.day;
          G.time = d.time;
          G.dayLen = d.dayLen;
          G.phase = d.phase;
          G.over = d.over;
          Object.assign(G.p, d.p);
          Object.assign(G.world, d.world);
          G.people = d.people;
          document.getElementById('overlay').classList.add('h');
          document.getElementById('charname').textContent = G.p.name;
          document.getElementById('charname').style.display = 'block';
          document.querySelectorAll('.abtn[data-a]').forEach((btn) => {
            btn.addEventListener('click', () => doAction(btn.dataset.a));
          });
          LP.innerHTML = '';
          logGap();
          log('[시스템] 저장된 게임을 불러왔습니다.', 'sy');
          log(`DAY ${G.day} · ${G.p.name} · HP ${G.p.hp}`, 'in');
          setupInput();
          fullUpdate();
          startTimer();
          return true;
        } catch (e) {
          toast('불러오기 실패', 'err');
          return false;
        }
      }
      function hasSave() {
        return !!localStorage.getItem(SAVE_KEY);
      }
      function deleteSave() {
        localStorage.removeItem(SAVE_KEY);
        toast('저장 삭제됨', '');
      }

      showTitle();
    </script>
  </body>
</html>
